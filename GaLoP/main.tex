% Document Type: LaTeX 2e
\documentclass[12pt,fleqn,landscape]{article}
% \documentclass[handout]{beamer}



\usepackage{upgreek,latexsym, amssymb, amsmath, amsfonts, mathrsfs} 
\usepackage{eucal,upref,yfonts,eufrak,stmaryrd,graphics,color} 
\usepackage[pdftex]{graphicx}
\usepackage{times}
\usepackage[all]{xy} 


\newcounter{chapter}

\setcounter{chapter}{2}

\usepackage{slide_style_new} 

\usepackage{ndj} 

% MACROS USED IN THE SLIDES

\newcommand{\tP}{\tt p}
\newcommand{\Data}{\mathbb{D}}

\newcommand{\where}{?}





\begin{document}\sffamily\bfseries\boldmath



\newcommand{\arity}[2]{\stackrel{\tt#1}{#2}}


\newcommand{\lexp}{$\lambda$-expression}
\newcommand{\lc}{$\lambda$-calculus}
\newcommand{\lopen}{\Lambda^o}
\newcommand{\lclosed}{\Lambda^\bullet}
\newcommand{\lnf}{\Lambda^{nf}}



\newcommand{\mv}[2]{R_{#2}:=R_{#1}}

\newcommand{\out}{\mbox{\bf out}}
\newcommand{\ifc}{\mbox{\bf if}}
\newcommand{\thenc}{\mbox{\bf then}}
\newcommand{\elsec}{\mbox{\bf else}}
\newcommand{\nil}{\mbox{\bf skip}}
\newcommand{\false}{\mbox{\sl false}}
\newcommand{\true}{\mbox{\sl true}}
\newcommand{\while}{\mbox{\bf while}}
\newcommand{\decl}{\mbox{\sl declassify}}
\newcommand{\dow}{\mbox{\bf do}}
\newcommand{\ew}{\mbox{\bf endw}}
\newcommand{\eif}{\mbox{\bf fi}}
\newcommand{\casec}{\mbox{\bf case}}
\newcommand{\ofc}{\mbox{\bf of}}
\newcommand{\letc}{\mbox{\bf let}}
\newcommand{\inc}{\mbox{\bf in}}


\newcommand{\dobf}[1]{dob(#1)}

\newcommand{\pp}[1]{ ^{#1.}}
\newcommand{\outp}{\mbox{\bf output}}
\newcommand{\inpp}{\mbox{\bf input}}

%\newcommand{\skipc}{\mbox{\bf skip}}
\newcommand{\skipc}{\nil}


\color{Black}\LARGE



%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Title

\thispagestyle{empty}
{\ }\vspace{2ex}
\begin{center} \Huge 
   \rule{18cm}{5pt} \\[1ex]
   \rouge{Partial Evaluation and Normalisation by Traversals} \\
   
   \rule{18cm}{5pt}
\end{center}


\begin{center}\LARGE

Work in progress by:
\vair

\bi
\item 
 \bleu{Daniil Berezun}\\\hair
\vertt{State University of St. Petersburg}\\
\vair\vair

\item 
 \bleu{Neil D. Jones}\\\hair
\vertt{ DIKU, University of Copenhagen (prof.\ emeritus)}\\
\ei
\end{center}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{A  belated  observation (last year)}

The much-studied game semantics for PCF can be thought of 

\vertt{as a PCF interpreter}.


\bc
Ong \cite{ong2015} shows that
\ec



\bq
\bleu{a {\lexp} $M$ can be evaluated (normalised) by an algorithm that constructs a \vertt{traversal} of $M$.}
\vair\vair

A traversal is a sequence of 
\vair
\bi
\item \vertt{subexpressions  of $M$}. This is a finite set, whose elements we will call \rouge{tokens}

\hfill \bleu{(think: \noir{$M$} = program, \noir{tokens} = \underline{program points})}
\vair

\item any token in a traversal may have \vertt{back pointers} (aka. justifiers).
\ei
\eq

\vair\vair


With this approach to normalisation: there is \rouge{\em no need for $\beta$-reduction, environments, ``thunks'' or ``closures''} to do the evaluation(!)
\vair\vair

\hfill\vertt{Origin: research on full abstraction for PCF.}
\end{slide}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Back pointer magic: doubling a Church Numeral }



\noir{Church numeral for $n: \lambda s \lambda z\ .\  s(\cdots (s z)\cdots)$}
\vair


\bleu{
$\ba{ll}
double&=   \lambda n s z \  .\  n s  (n s z) \\
\multicolumn{2}{l}{=  \lambda n\lambda s\lambda z \ .\ ((n @_1 s) @_2 ((n @_3 s) @_4 z))} \\
\ea
$}

%\vspace{-10mm}

\bc
\setlength{\unitlength}{0.06in}%

\begin{picture}(40,30)(-40,-20)

\put (20,26){$@_5$}

\put (20,24){\vector(-1,-1){10}}
\put (20,24){\vector(3,-2){17}}

\put (6,9){$\lambda n$}

\put (8,8){\vector(0,-1){5}}


\put (36,9){$\lambda s1$\hspace{8mm}\rouge{Church}}

\put (38,8){\vector(0,-1){5}}

\put (6,-2){$\lambda s$}

\put (8,-3){\vector(0,-1){5}}

\put (36,-2){$\lambda z1$\hspace{8mm}\rouge{numeral }}

\put (36,-13){$@_6$ \hspace{18mm}\rouge{1}}

\put (38,-15){\vector(-1,-1){10}}
\put (38,-15){\vector(1,-1){10}}

\put (26,-30){$s1$}
\put (46,-30){$z1$}



\put (38,-3){\vector(0,-1){5}}

\put (6,-13){$\lambda z$}

\put (8,-14){\vector(0,-1){5}}

\put (6,-24){$@_2$}

\put (8,-26){\vector(-1,-1){14}}
\put (8,-26){\vector(3,-2){20}}


\put (-11,-44){$@_1$}

\put (-9,-45){\vector(-1,-1){10}}
\put (-9,-45){\vector(1,-1){10}}

\put (-21,-59){$n$}
\put (-1,-59){$s$}



\put (27,-44){$@_4$}

\put (29,-45){\vector(-1,-1){10}}
\put (29,-45){\vector(1,-1){10}}

\put (17,-59){$@_3$}
\put (37,-59){$z$}

\put (19,-59){\vector(-1,-1){10}}
\put (19,-59){\vector(1,-1){10}}

\put (7,-73){$n$}
\put (27,-73){$s$}





\end{picture}
\ec
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Traversal  of \bleu{double 1}: steps 1 $\to$ 7}

Save backpointers on the way down.

(backpointer: from ``here'' to earlier token)


\bc
\setlength{\unitlength}{0.06in}%

\begin{picture}(40,30)(-40,-11)

\put (14,26){$\bleu{1}$}

\put (18,26){$@_5$}

\put (20,24){\vector(-1,-1){10}}
\put (20,24){\vector(3,-2){17}}


\put (2,9){$\bleu{2}$}

\put (6,9){$\lambda n$}

\put (8,8){\vector(0,-1){5}}


\put (36,9){$\lambda s1$\hspace{8mm}\rouge{Church}}

\put (38,8){\vector(0,-1){5}}

\put (2,-2){$\bleu{3}$}

\put (6,-2){$\lambda s$}

\put (8,-3){\vector(0,-1){5}}

\put (36,-2){$\lambda z1$\hspace{8mm}\rouge{numeral }}

\put (36,-13){$@_6$ \hspace{18mm}\rouge{1}}

\put (38,-15){\vector(-1,-1){10}}
\put (38,-15){\vector(1,-1){10}}

\put (26,-30){$s1$}
\put (46,-30){$z1$}



\put (38,-3){\vector(0,-1){5}}

\put(2,-13){$\bleu{4}$}


\put (6,-13){$\lambda z$}

\put (8,-14){\vector(0,-1){5}}


\put(2,-24){$\bleu{5}$}

\put (6,-24){$@_2$}

\put (8,-26){\vector(-1,-1){14}}
\put (8,-26){\vector(3,-2){20}}


\put(-15,-44){$\bleu{6}$}

\put (-11,-44){$@_1$}

\put (-9,-45){\vector(-1,-1){10}}
\put (-9,-45){\vector(1,-1){10}}


\put(-25,-59){$\bleu{7}$}

\put (-21,-59){$n$}
\put (-1,-59){$s$}



\put (27,-44){$@_4$}

\put (29,-45){\vector(-1,-1){10}}
\put (29,-45){\vector(1,-1){10}}

\put (17,-59){$@_3$}
\put (37,-59){$z$}

\put (19,-59){\vector(-1,-1){10}}
\put (19,-59){\vector(1,-1){10}}

\put (7,-73){$n$}
\put (27,-73){$s$}





\end{picture}
\ec
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Traversal  of \bleu{double 1}: steps 8 $\to$ 11 }


(find $n$ binding to $\lambda s1\ldots$ by backpointer)

%(find $@$ backpointer of $n$'s dynamic binder)

\bc
\setlength{\unitlength}{0.06in}%

\begin{picture}(40,30)(-40,-4)

\put (14,26){$\vertt{1}$}

\put (18,26){$@_5$}

\put (20,24){\vector(-1,-1){10}}
\put (20,24){\vector(3,-2){17}}


\put (2,9){$\vertt{2}$}

\put (6,9){$\lambda n$}

\put (8,8){\vector(0,-1){5}}


\put (36,9){$\lambda s1$\hspace{8mm}\bleu{8}}

\put (38,8){\vector(0,-1){5}}

\put (2,-2){$\vertt{3}$}

\put (6,-2){$\lambda s$}

\put (8,-3){\vector(0,-1){5}}

\put (36,-2){$\lambda z1$\hspace{8mm}\bleu{9}}

\put (36,-13){$@_6$ \hspace{8mm}\bleu{10}}

\put (38,-15){\vector(-1,-1){10}}
\put (38,-15){\vector(1,-1){10}}

\put (26,-30){$s1$}
\put (26,-35){\bleu{11}}



\put (46,-30){$z1$}



\put (38,-3){\vector(0,-1){5}}

\put(2,-13){$\vertt{4}$}


\put (6,-13){$\lambda z$}

\put (8,-14){\vector(0,-1){5}}


\put(2,-24){$\vertt{5}$}

\put (6,-24){$@_2$}

\put (8,-26){\vector(-1,-1){14}}
\put (8,-26){\vector(3,-2){20}}


\put(-15,-44){$\vertt{6}$}

\put (-11,-44){$@_1$}

\put (-9,-45){\vector(-1,-1){10}}
\put (-9,-45){\vector(1,-1){10}}


\put(-25,-59){$\vertt{7}$}

\put (-21,-59){$n$}
\put (-1,-59){$s$}



\put (27,-44){$@_4$}

\put (29,-45){\vector(-1,-1){10}}
\put (29,-45){\vector(1,-1){10}}

\put (17,-59){$@_3$}
\put (37,-59){$z$}

\put (19,-59){\vector(-1,-1){10}}
\put (19,-59){\vector(1,-1){10}}

\put (7,-73){$n$}
\put (27,-73){$s$}





\end{picture}
\ec
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Traversal  of \bleu{double 1}: steps 12 $\to$ 16}


(find $s1$ binding to $s$ by backpointer)



\bc
\setlength{\unitlength}{0.06in}%

\begin{picture}(40,30)(-40,-4)

\put (14,26){$\vertt{1}$}

\put (18,26){$@_5$}

\put (20,24){\vector(-1,-1){10}}
\put (20,24){\vector(3,-2){17}}


\put (2,9){$\vertt{2}$}

\put (6,9){$\lambda n$}

\put (8,8){\vector(0,-1){5}}


\put (36,9){$\lambda s1$\hspace{8mm}\vertt{8}}

\put (38,8){\vector(0,-1){5}}

\put (2,-2){$\vertt{3}$}

\put (6,-2){$\lambda s$}

\put (8,-3){\vector(0,-1){5}}

\put (36,-2){$\lambda z1$\hspace{8mm}\vertt{9}}

\put (36,-13){$@_6$ \hspace{8mm}\vertt{10}}

\put (38,-15){\vector(-1,-1){10}}
\put (38,-15){\vector(1,-1){10}}

\put (26,-30){$s1$}
\put (26,-35){\vertt{11}}



\put (46,-30){$z1$}
\put (46,-35){\bleu{13}}



\put (38,-3){\vector(0,-1){5}}

\put(2,-13){$\vertt{4}$}


\put (6,-13){$\lambda z$}

\put (8,-14){\vector(0,-1){5}}


\put(2,-24){$\vertt{5}$}

\put (6,-24){$@_2$}

\put (8,-26){\vector(-1,-1){14}}
\put (8,-26){\vector(3,-2){20}}


\put(-15,-44){$\vertt{6}$}

\put (-11,-44){$@_1$}

\put (-9,-45){\vector(-1,-1){10}}
\put (-9,-45){\vector(1,-1){10}}


\put(-25,-59){$\vertt{7}$}

\put (-21,-59){$n$}

\put (-1,-59){$s$}

\put(-3,-65){$\bleu{12}$}



\put (27,-44){$@_4$}

\put(21,-44){$\bleu{14}$}

\put (29,-45){\vector(-1,-1){10}}
\put (29,-45){\vector(1,-1){10}}

\put (17,-59){$@_3$}

\put(11,-59){$\bleu{15}$}

\put (37,-59){$z$}

\put (19,-59){\vector(-1,-1){10}}
\put (19,-59){\vector(1,-1){10}}

\put (7,-73){$n$}

\put(6,-78){$\bleu{16}$}

\put (27,-73){$s$}





\end{picture}
\ec
\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Traversal  of \bleu{double 1}: steps 17 $\to$ 23}

(find second $n$ binding by backpointer, \dots)


\bc
\setlength{\unitlength}{0.06in}%

\begin{picture}(40,30)(-40,-4)

\put (14,26){$\vertt{1}$}

\put (18,26){$@_5$}

\put (20,24){\vector(-1,-1){10}}
\put (20,24){\vector(3,-2){17}}


\put (2,9){$\vertt{2}$}

\put (6,9){$\lambda n$}

\put (8,8){\vector(0,-1){5}}


\put (36,9){$\lambda s1$\hspace{8mm}\vertt{8\bleu{, 17}}}

\put (38,8){\vector(0,-1){5}}

\put (2,-2){$\vertt{3}$}

\put (6,-2){$\lambda s$}

\put (8,-3){\vector(0,-1){5}}

\put (36,-2){$\lambda z1$\hspace{8mm}\vertt{9\bleu{, 18}}}

\put (36,-13){$@_6$ \hspace{8mm}\vertt{10\bleu{, 19}}}

\put (38,-15){\vector(-1,-1){10}}
\put (38,-15){\vector(1,-1){10}}

\put (26,-30){$s1$}
\put (26,-35){\vertt{11\bleu{, 20}}}



\put (46,-30){$z1$}
\put (46,-35){\vertt{13\bleu{, 22}}}



\put (38,-3){\vector(0,-1){5}}

\put(2,-13){$\vertt{4}$}


\put (6,-13){$\lambda z$}

\put (8,-14){\vector(0,-1){5}}


\put(2,-24){$\vertt{5}$}

\put (6,-24){$@_2$}

\put (8,-26){\vector(-1,-1){14}}
\put (8,-26){\vector(3,-2){20}}


\put(-15,-44){$\vertt{6}$}

\put (-11,-44){$@_1$}

\put (-9,-45){\vector(-1,-1){10}}
\put (-9,-45){\vector(1,-1){10}}


\put(-25,-59){$\vertt{7}$}

\put (-21,-59){$n$}

\put (-1,-59){$s$}

\put(-3,-65){$\vertt{12}$}



\put (27,-44){$@_4$}

\put(21,-44){$\vertt{14}$}

\put (29,-45){\vector(-1,-1){10}}
\put (29,-45){\vector(1,-1){10}}

\put (17,-59){$@_3$}

\put(11,-59){$\vertt{15}$}

\put (37,-59){$z$}

\put(36,-64){$\bleu{23}$}

\put (19,-59){\vector(-1,-1){10}}
\put (19,-59){\vector(1,-1){10}}

\put (7,-73){$n$}

\put(6,-78){$\vertt{16}$}

\put (27,-73){$s$}

\put(26,-78){$\bleu{21}$}





\end{picture}
\ec
\end{slide}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Overview}



A view of the Oxford normalisation procedure (ONP for short): It is
\vair

\bc\vertt{an interpreter for {\lexp}s}
\ec




\bi

\item ONP systematically builds  traversal set   $\mathfrak{Trav}(M)$. What and How?
\vair\vair

\item Traversal : \hfill \rouge{$tr = t_0  \cdot\ldots \cdot t_n$} \hair  $t_i$ is a \bleu{token} (subexpression  of $M$)
\vair\vair

\item  \bleu{Syntax-directed inference rules}: based on syntax of the end-token \rouge{$t_n$}
\vair
\item Action: add  0, 1 or more extensions of \rouge{$tr$} to  $\mathfrak{Trav}(M)$. For each,
\vair
\bi 
\item Add a new token \rouge{$t'$}, yielding \rouge{$tr \cdot t'$}
\vair

\item Add a back pointer from \rouge{$t'$} \hfill \vertt{(or none; depends on form of token \rouge{$t_n$})}
\vair
 \ei


\ei


 \rouge{Data types:}
 \bigskip
 
$
\ba{ll}tr \in Tr =  Item\ ^* & \mbox{\bleu{Traversal = a list of items}}
 \\\\
 Item = subexpression(M) \times Tr & \mbox{\bleu{Item = a token and a back pointer}}

\ea$


\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Some characteristics}



Oxford \vertt{normalisation procedure }
\vair

\bi

\item applies to simply-typed {\lexp}s
\vair

\item begins by translating $M$ into \bleu{$\eta$-long form}
\vair

\item realises the \vertt{head linear} reduction of $M$, one step at a time
\vair

\item \rouge{Correctness:}  by game semantics and categories, using $M$'s types
\ei
\vair

\bleu{Properties of  the normalisation procedure:} 
\vair\vair

 \hfill ONP uses no  $\beta$-reduction:  \vertt{all is based on subexpressions of $M$.}
\vair\vair

While running,  ONP   \rouge{does not use the types of $M$} at all.
 
 
\bigskip

\vertt{\underline{Goals of this research}}: 
\bi

\item Extend ONP to UNP, for the \rouge{untyped} lambda calculus

\item \bleu{Partially evaluate} a normaliser with respect to ``static'' input \noir{$M$}.

Use this to \rouge{ compile}  $\lambda$-calculus into a low-level language.
\ei


\end{slide}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{partial evaluation, briefly}

A partial evaluator is a \bleu{program specialiser}. Defining property of $spec$:

$$
\forall p\in \mathit{Programs}\ .\ \forall s, d \in \mathit{Data}\ . \ 
\lsem \lsem spec\rsem (p, s)\rsem (d) = \lsem p\rsem (s, d)
$$


\bi

\item Program speedup by \rouge{precomputation}.
Applications: \bleu{compiling}, and \bleu{compiler generation} (from an \vertt{interpreter},
and by \vertt{self-applying}  $\mathit{spec}$).


\item Given program $p$ and ``\rouge{static}'' data $s$, $\mathit{spec}$ builds a \bleu{\em residual program} $p_s \stackrel{def}{=} \lsem spec\rsem (p, s)$. 

\item When run on any remaining ``\rouge{dynamic}'' data $d$, residual program $p_s$ computes \vertt{what $p$ would have computed on both} data inputs $s$ and $d$.
\vair\vair

\item Net effect: a \bleu{\em staging transformation}:  $\lsem p\rsem (s, d)$ is a \rouge{1 stage} computation; but $\lsem \lsem spec\rsem (p, s)\rsem (d)$ is a  \rouge{2 stage} computation.
\vair

\item \vertt{Well-known in recursive function theory, as the $S$-1-1 theorem.}

\item \vertt{Partial evaluation = engineering   the $S$-1-1 theorem on real programs.}

\ei
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Could normalisation be staged? }


\be

\item The $spec$ equation for a normaliser program NP:

\bc\fbox{$
\forall M \in \Lambda\ . \ 
\lsem\  \lsem spec\rsem (\mbox{NP}, M)\rsem ()  = \lsem \mbox{NP}\rsem (M)
$}
\ec

\vair

\item $\lambda$-calculus tradition:  $M$ is self-contained; there is no  dynamic data.
\vair

So \vertt{why break normalisation into 2 stages}?
\vair

\be
\item The specialiser output  NP$_M = \lsem spec\rsem(\mbox{NP}, M)$ can be in a  \bleu{much simpler language} than the \lc.
\vair

Our candidate: \rouge{LLL, a ``low-level language''} (syntax  later).


\item A next step: consider the \bleu{computational complexity} of normalising,  if $M$ is applied to an \vertt{external input }$d$ at run-time.
\vair

\bc\fbox{\rouge{$
\forall M \in \Lambda, d \in D\ . \ 
\lsem\  \lsem spec\rsem \, \mbox{NP}\ M\rsem(d)\  = \lsem \mbox{NP}\rsem \, (M\ d)
$}}
\ec





\item 2 stages will be natural for \bleu{\em semantics-directed compiler generation}. 
\vertt{Aim: use LLL as  an intermediate language to express semantics}.
\vair
\ee


 
\ee


\end{slide}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{The  residual program\ \   \noir{NP$_M = \lsem \lowercase{spec}\rsem \, \mbox{NP}\ M$} }


\rouge{If} NP   is \bleu{semi-compositional}:
\vair

\hfill\vertt{Any recursive \noir{NP} call has \underline{\underline{a substructure of \noir{$M$}}}  as argument.}
\vair\vair

\rouge{Then:}

\bi
\item The partial evaluator can do, at specialisation time, 

\hfill \bleu{all of the \noir{NP} operations that depend only on \noir{$M$}}
\vair\vair

\item So NP$_M$ performs \vertt{\underline{no operations at all}} on  lambda expressions (!)
\vair\vair

\item NP$_M$ contains  ``residual code'':
\bi
\item operations to extend the traversal; and (sometimes)

\item operations to follow back pointers
\ei
\vair\vair

\item Subexpressions of $M$ will appear, but are only used as \rouge{tokens}: 

Tokens are \vertt{indivisible}, only used for equality comparisons with other tokens

\ei\end{slide}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{The low-level language  \noir{LLL}}

LLL is a tiny \bleu{tail recursive first-order functional} language. Essentially a machine language with a heap.
Functional version of \rouge{\sc while} in book:
\vair

\hair\hair \vertt{Computability and Complexity from Programming Perspective} \vair

\rouge{SYNTAX}

\bp
\noir{program ::=  f1 x = e1  ...  fn x = en}

\noir{e       ::=  x     | f e}                                   \mbox{\rm call in tail position}
\noir{         |   token | case e of token1 -> e1 ... tokenn -> en}
\noir{         |   (e,e) | case e of (x,y) -> e}
\noir{         |   []    | case e of [] -> e x:y -> e }

\noir{x       ::= variable}

\noir{token   ::= an atomic symbol (from a fixed alphabet)}

\ep

\rouge{Variables have SIMPLE TYPES}: 

\bp
                     \noir{tau ::=  Token  |  tau x tau  |  [ tau ]   }

\ep

A token, or a product type, has a \vertt{static structure}, fixed for any one program. A list type
\ {\tt [tau]}\  is \rouge{dynamic}, with constructors {\tt [] and :} 

\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{How to partially evaluate  \noir{NP} (in program form)\\ 
with respect to \vertt{static} $\lambda$-expression \noir{$M$} ?}


\be

\item \bleu{Annotate}  parts of NP   as either \vertt{static} or \rouge{dynamic}. Variables ranging over
\vair

\be
\item\label{onpsyntax} \vertt{tokens} are \vertt{static}, i.e., {\lexp}s \hfill (subexpressions of $M$);
\item\label{onpbps} \rouge{back pointers} are \rouge{dynamic};
\item\label{onptraversals} so the \rouge{traversal} being built is \rouge{dynamic} too.
\ee
\vair

\item Classify data \ref{onpsyntax} as \vertt{static}  \hfill \vertt{(there are only \bleu{finitely many})}
\vair

\item Classify data \ref{onpbps},  \ref{onptraversals} as \rouge{dynamic}
\hfill \vertt{(there are \bleu{unboundedly many})}
\vair

\item Computations in NP are either  \vertt{unfolded} \hfill(done at PE time) 

or \hfill  \rouge{residualised} (runtime code is generated to \rouge{do them later})
\bi
\item Perform \vertt{fully static} computations  \vertt{at partial evauation time}.

\item Operations to build or test a traversal: generate  \rouge{residual code}.
\ei

\ee


\end{slide}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Status: our work on simply-typed \lc }

\be

\item We have one version of ONP  in  \bleu{\sc Haskell} and another in \bleu{\sc scheme}
\vair

\item {\sc Haskell} version includes: \vertt{ typing; conversion to eta-long form;  the traversal algorithm itself; and construction of the normalised term}.
\vair

\item {\sc Scheme} version: nearly ready to apply automatic partial evaluation. Plan: use  the \bleu{\sc unmix} partial evaluator  (Sergei Romanenko).
\vair
\vair

\item The LLL output program size  is only \rouge{linearly larger} than $M$, satisfying 
$$|p_M| = O(|M|)$$


\item We have   handwritten ONP-gen: a \rouge{\em generating extension}  of ONP. 

Symbolically,
$$
\mbox{If\ }p_M = \lsem \mbox{ONP-gen} \rsem^{\sc scheme} (M)
\mbox{\ then\ }
\forall M \ .\ \lsem M\rsem^\Lambda =  \lsem p_M \rsem^{LLL} 
$$


\vertt{Currently:  LLL = {\tt scheme}, so the output $p_M$ is  a {\sc scheme}  program.} 
\smallskip

\item Next step: make LLL a clean stand-alone  subset of {\sc haskell}
\ee

\end{slide}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{MORE TO DO,  for the \bleu{simply-typed} \lc }

\be

\item Extend the approach to \vertt{programs with input data}.
\vair

\item Produce a generating extension, \vertt{automatically,} by \bleu{specialising the specialiser to a $\Lambda$-traverser},  using {\sc unmix}. 
\vair

\item Property of {\sc unmix}: the generating extension's output programs are  in {\sc scheme}. 

\bi
\item 
\vertt{Practical advantage}: $p_M$ is directly executable (e.g., by {\sc racket}).
\vair

\item \vertt{Disadvantage}: $p_M$ in this form could be system-dependent. 
\ei
\vair

\item To do: redefine the {\sc lll} language formally, e.g., a tiny

\hfill  first-order  language with {\sc haskell}-like syntax.
\vair\vair

\item Then produce programs in  {\sc lll}  instead of {\sc scheme}.

\ee

\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Status:  our work on the \bleu{untyped} \lc }

\be

\item UNP is a normaliser for $\Lambda^{untyped}$.
\vair

\item A single traversal item may have \bleu{two back pointers} (in comparison: ONP uses 1).
\vair

\item  UNP   is defined \vertt{semi-compositionally} by   recursion on  syntax of  $\lambda$-expression $M$.
\vair

\item UNP has been  done in {\sc Haskell} and works on a variety of examples. (A more abstract definition of UNP is on the way.)

\item By specialising UNP, an \bleu{arbitrary untyped $\lambda$-expression} can be translated to {\sc lll}.
\vair

\item Correctness proof: pending.

\vair

\item No {\sc scheme} version or generating extension has yet been done.
\ee

\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Towards separating programs from data in $\Lambda$}


\be

\item An idea: regard a \vertt{computation of $\lambda$-expression $M$ on input $d$} as a

\hfill \rouge{ \bleu{two-player game} between the {\sc lll}-codes for $M$ and $d$}.
\vair

\item An example: {\tt mul},  usual $\lambda$-calculus definition on Church numerals. 
\vair

\item Loops from out of nowhere:
\bi
\item \vertt{Neither {\tt mul} nor the data contain loops}; 
\vair

\item but  {\tt mul} is compiled  into \bleu{an {\sc lll}-program with two nested loops}. Applied to two Church numerals, it  computes their product.
\vair

\item Expect: can do the computation  \vertt{entirely without back pointers}.
\ei
\vair

\item Current work: express such program-data games in a \rouge{\em communicating} version of {\sc lll}. 

A  lead: apply traditional methods for compiling  {\em remote function calls}.

\vair

\item Think about \bleu{complexity} and \bleu{data-flow analysis} of such programs.

\ee






\end{slide}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{Some related work}\bibliographystyle{unsrt}

\vspace{-25mm}
\bibliography{slidesgames}

\nocite{*}

\end{slide}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{\noir{\tt scheme}  example:  \noir{ONP} specialised to \vertt{$M$} = \lowercase{\vertt{\tt mul 3 2}} }

$M= \lambda m\, n\, s\, z\ .\ m(n\, s) z$  multiplies two Church numerals. 
\vair

\hfill \bleu{$\eta$-long form: longish! }


  
Residual code to add traversal items. 
\bi
\item\rouge{ Tokens}: $A,B,\ldots \in Subexpressions(M)$

\item \rouge{Functions} $a,b,\ldots : Tr \to Tr$\hfill (big-step:$current\ trav \to final\ trav$)
\ei


\bp
\noir{  
main    =  print  (reverse (a [ $\langle$A []$\rangle$ ]))  -- outermost $\lambda()$

a tr = b ($\langle$B tr$\rangle$ : tr)                    -- long apply @

b tr = c ($\langle$C tr$\rangle$ : tr)                    -- control  to $\lambda{mnsz}\,.\,m(ns)z$

c tr = d ($\langle$D (dynamicbinder C tr)$\rangle$ : tr)  -- find binder of variable $m$
d tr = cgoto1 tr                         -- control transfer to $m$'s value

e tr = f ($\langle$F (dynamicbinder C tr)$\rangle$ : tr)  -- find binder of variable $n$
f tr = cgoto2 tr                         -- control transfer to $n$'s value
g tr = h ($\langle$H (dynamicbinder C tr)$\rangle$ : tr) -- $\lambda.e$: find $s$ binder 
h tr = cgoto3 tr                        -- control transfer to $s$'s value
-- etc, \bleu{one for each $M$ subexpression}
}\ep

\end{slide}



\begin{slide}{Variables:  \noir{backpointer search}}

Suppose a variable {\tt x}$_i$ is encountered, 
and it is bound \vertt{statically} by abstraction node \vertt{$\lambda\  x_1\ldots x_n\ .\ N$} in $\lambda$-expression 
\vertt{$M$}.
\vair

Function \rouge{\tt dynamicbinder}  is given 
\vair

\hspace{25mm}\bt{lcl}
\vertt{\tt have} &=&  a static abstraction node $\lambda\  x_1\ldots x_n\ .\ N$\\
{\tt tr} &=&  the current traversal
\et
\vair

It will follow back pointers in
 the current traversal, to find
\bi
\item the \rouge{dynamic} token in the traversal
\item that contains this \vertt{static} binding of variable {\tt x}$_i$.
\ei
\vair

\bp
\noir{
\rouge{\tt dynamicbinder} \vertt{have} tr =  
  case tr of
  $\langle$r tr'$\rangle$ : tr'' -> 
    if r == \vertt{have}  
    then tr 
    else case tr' of                                 
         ( _ : tr''') -> \rouge{\tt dynamicbinder} \vertt{have}  tr'''  \noir{\rm{(follow the back pointer)}}
         [ ]          -> - BUG -}
 \ep



\begin{slide}{ ``computed \noir{GOTO}'' function for \lowercase{$x_i$} in \lowercase{$\lambda x_1\cdots x_n}\,.\,N$}

\vertt{The idea:}
\vair

Function {\tt cgoto$i$(tr)} realises a control transfer to the item $\langle token,bp\rangle$ in traversal {\tt tr} for  the value of   
$x_i$ in $\lambda x_1\cdots x_n\,.\,N$. 

\bp
\noir{
cgoto1 $\langle$C _$\rangle$ : tr = oa $\langle$OA tr$\rangle$ : tr
cgoto1 $\langle$E _$\rangle$ : tr = ob $\langle$F tr$\rangle$ : tr
cgoto1 $\langle$G _$\rangle$ : tr = ac $\langle$H tr$\rangle$ : tr
cgoto1 $\langle$I _$\rangle$ : tr =  i $\langle$I tr$\rangle$ : tr
cgoto1     _      = $\langle$BUG []$\rangle$ : tr
     
cgoto2 $\langle$C _$\rangle$ : tr = wa $\langle$WA tr$\rangle$ : tr
cgoto2 $\langle$E _$\rangle$ : tr =  m $\langle$M tr$\rangle$ : tr
cgoto2 $\langle$G _$\rangle$ : tr =  k $\langle$K tr$\rangle$ : tr
cgoto2     _     =  $\langle$BUG []$\rangle$ : tr

cgoto3 $\langle$C _$\rangle$ : tr = ac $\langle$AC tr$\rangle$ : tr
cgoto13    _     = $\langle$BUG []$\rangle$ : tr

cgoto4$\langle$C _$\rangle$ : tr  = ag $\langle$AG tr$\rangle$ : tr
cgoto4     _     = $\langle$BUG []$\rangle$ : tr
 } \ep
\end{slide}


\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{An old dream: \\
\bleu{Semantics-directed compiler 
 generation} }

(Just a wild idea for now, needs much more thought and work.)
\vair\vair

Idea: specify \vertt{the semantics of a subject programming language}
\vair

\hfill (e.g., call-by-value $\lambda$-calculus, imperative languages, etc.) 
\vair

by \rouge{mapping  source programs into {\sc lll}}. 
\vair\vair

A ``gedankeneksperiment'', to get started: 
\vair\vair

\bleu{Express the semantics of $\Lambda$}
by \vertt{semi-compositional semantic rules} without variable environments, thunks, etc:
$$
\lsem\ \rsem^\Lambda : \Lambda \to \mbox{\sc lll}
$$


Expectations/hopes:
\bi

\item Reasonably many  programming languages can be specified this way


\item A generalising  framework: compiling, optimisation,\ldots\ tasks \bleu{can all be  reduced} to questions and algorithms  
concerning  LLL programs

 

\ei





\end{slide}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{A partial evaluator  compiles from $\Lambda$ to LLL}

Given a traversal algorithm NP and a $\lambda$-expression $M$,  the partial evaluato
yields an LLL program. The net effect is to  \bleu{factor}:
$$
\mbox{NP} : \Lambda \to \mathit{Traversals}
$$
into two stages:
$$
\mbox{NP}_1 : \Lambda \to  \mbox{LLL-pgms} \mbox{\ \ \vertt{and}\ \ }  \mbox{NP}_2 : \mbox{LLL-pgms} \to \mathit{Traversals}
$$
\vair
where
\bi
\item \mbox{NP}$_1 = \lsem \lowercase{spec}\rsem \, \mbox{NP}\ M$
\vair

\hfill \rouge{An {\sc lll}  program; result of partially evaluating ONP w.r.t.  input $M$}
\vair\vair

\item \mbox{NP}$_2 =  \lsem\ \_\ \rsem^{LLL}$ \hfill \vertt{the semantic function of LLL-programs}
\ei\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\end{document}

