\documentclass[a4paper, 10pt]{article}
\usepackage[margin=0.5in]{geometry}
% \usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[utf8]{inputenc}%кодировка
\usepackage[russian]{babel}%используем русский и английский языки с переносами
% \graphicspath{{/}}%путь к рисункам
\usepackage{cite}
\usepackage{multirow}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{ amssymb }
\usepackage{ amsmath}
\usepackage{listings}
\usepackage{xcolor}
\graphicspath{{pictures/}}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dred}{rgb}{0.545,0,0}
\definecolor{dblue}{rgb}{0,0,0.545}
\definecolor{lgrey}{rgb}{0.9,0.9,0.9}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}

\usepackage{pythontex}
\usepackage{minted}

% for printing trees
\usepackage{verbatim}

\usepackage[labelformat=empty]{caption}
\usepackage{fontspec}
\usepackage{polyglossia}
\setdefaultlanguage{english}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont{CMU Serif}
\setsansfont{CMU Sans Serif}
\setmonofont{CMU Typewriter Text}

\usepackage{stmaryrd}
\usepackage{amsfonts}
\newcommand\abs[1]{\left|#1\right|}

\usepackage{tikz}
\newcommand{\tikzmark}[3][]{\tikz[remember picture,baseline] \node [inner xsep=0pt,anchor=base,#1](#2) {#3};}
\usepackage{lscape}
\usepackage{pdflscape}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}

\begin{document}

\tableofcontents
\newpage

\section{Traversal for $\Lambda^{Untyped}$}

\subsection{Introduction}
Algorithm constructs a traversal for arbitrary untyped lambda expression \textbf{M}.\\
Syntax for input lambda term:\\
$\Lambda\ ::=\ \lambda x . \Lambda\ |\ \Lambda\ @\ \Lambda\ |\ x$

Let \textit{traversal} be a 
justified sequence of \textit{tokens} (i.e. \textbf{M} subexpressions) with several backpointers.

Current algorithm version uses 4 different kinds of backpointers:
\begin{enumerate}
\item \textit{bp1\_} --- doesn't used for constructing traversal at all, it is \textbf{only} used for reconstructing the output term from the traversal has being generated; (this pointer is omitted in this notes)
\item \textit{bp2\_} --- a pointer to the last unfinished application (i.e. application that left-hand side is already traversed or is under consideration at the moment but its left-hand side haven't been considered yet);
\item \textit{bp3\_} --- pointer that bounds (Lam)-s with their arguments;\\
for examples: $(\lambda x . \lambda y . \cdots)\ @_1\ M_1)\ @_2\ M_2$\\will generate the following traversal (all other backpointers are omitted)
\[\tikzmark{1}{$@_2$}\ \ \tikzmark{2}{$@_1$}\ \ \tikzmark{3}{$\lambda x$}\ \ \tikzmark{4}{$\lambda y$}\ \ \dots \]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (3.north) to[bend right] (2.north);}
  \color{red}{\draw[->] (4.north) to[bend right] (1.north);}
\end{tikzpicture}
\textbf{NB}: not only (Lam)-s could have \textit{bp2\_} pointer; other tokens also have this pointer but with only one purpuse: support o finding corresponding pointers fot (Lam)-s;
\item \textit{bp4\_} --- a binder pointer; \textit{Invariant}: from each (BVar) token "x" it points to its correct dynamic binder (Lam) "$\lambda x . \cdots$"
\end{enumerate}

\textbf{Comments:}
\begin{itemize}
\item also each traversal element have a boolean flag; (if it is setted that means that in this point head linear reduction got stuck and we started to look for the latest unfinished application);
\item there is no difference between a free variable case and a bound variable case whose binder(lambda) is not "applied";
\item pointers \textit{bp2\_} and \textit{bp3\_} are \textbf{very similar} but still different;
\end{itemize}

\subsection{Rules for construction traversal and backpointers}
On each step algorithm extends a current traversal \textit{tr} by induction over traversal length, i.e. by adding a new justified token.\\
Let \textit{x} denotes the last element of \textit{tr},
$tr$ = $x:t$,
$bp_{i_x}$ denotes the i-th pointer of token \textit{x},
LUA is an abbriviation for "Last Unfinished Application",
flu is an abbriviation for "Find Last Unfinished application". \\

\begin{minted}[escapeinside=XX]{haskell}


(X$e_1 @ e_2,\ b_x,\ bp_{2_x},\ bp_{3_x},\ bp_{4_x}$X):t = (X$e_1$X, F, flu, flu, computeBI e |tr|):tr
(X$\lambda z . e\ ,\ b_x,\ bp_{2_x},\ bp_{3_x},\ bp_{4_x}$X):t = (X$e$X, F, flu, flu, computeBI e |tr|):tr
(X$BVar\ z,\ b_x,\ bp_{2_x},\ bp_{3_x},\ bp_{4_x}$X):t = if exists a bound argument (e, i)
  then (e, F, flu, flu, computeBI e i):tr
  else THE_SAME_AS_FVar_CASE
  where e is a term to be substituted instead of variable z
        i is an application location in traversal (e is a child of this application)
(X$FVar\ z,\ b_x,\ bp_{2_x},\ bp_{3_x},\ bp_{4_x}$X):t = if exists (the latest one) unfinished application (e, i)
  then if e == (Abs)
    then (e, False, X$bp_{2_x}$X, 0, computeBI tr e X$bp_{2_x}$X):(x, True, X$bp_{2_x},\ bp_{3_x},\ bp_{4_x}$X):t
    else (e, False, i  , 0, computeBI tr e X$bp_{2_x}$X):(x, True, X$bp_{2_x},\ bp_{3_x},\ bp_{4_x}$X):t
  else END_OF_TRAVERSAL
  where e is an argument of the LUA
        i is a pointer to the "new" LUA

\end{minted}




\textbf{Pseudo-code:}
\begin{minted}{haskell}
input: tr@((x, b_x, bp2_x bp3_x, bp4_x):t)
case x of
  
  (App): e _    ||   (Abs): \ _ . e
    -> (e, False, findLastUnapplied, findLastUnapplied, computeBI e |tr|):tr

  (BVar): z
    if exists a bound argument (e, i)
    | Invariants:
    |   e --- term to be substituted instead of variable z
    |   i --- an application location in traversal (e is a child of this application)
    | Finding bound argument:
    |   1) make a step through bp4_x (Invariant: we reach a binder)
    |   2) if bp3_binder == 0
    |      then Nothing
    |      else make a step through bp3_binder (Invariant: we reach an (App): _ e2)
    |           return Just (e2, bp3_binder)
    then (e, False, findLastUnapplied, findLastUnapplied, computeBI e i):tr
    else GOTO_(FVar)

  (FVar): z
    if exists (the latest one) unfinished application (e, i)
    | Invariants:
    |   e --- argument of the LUA
    |   i --- pointer to the "new" LUA
    | Finding unfinished application:
    |   if bp2_x == 0
    |   then Nothing
    |   else make a step through bp2_x (Invariant: we reach an (App): _ e2)
    |        return Just (e2, bp2_app)
    then if e == (Abs)
    | then (e, False, bp2\_x, 0, computeBI tr e bp2_x):(x, True, bp2_x bp3_x, bp4_x):t
    | else (e, False, i     , 0, computeBI tr e bp2_x):(x, True, bp2_x bp3_x, bp4_x):t
    else END_OF_TRAVERSAL
\end{minted}

\subsection*{Auxiliary functions}
\begin{minted}{haskell}
-- function findLastUnapplied by traversal returns a last "unapplied" application
-- (i.e. such that there is not (Lam) that points to that application)
findLastUnapplied empty_traversal = 0
findLastUnapplied tr@((Abs _, _, _, 0    , _, _):xs) = 0     -- i.e. bp2_ == 0
findLastUnapplied tr@((Abs _, _, _, bp2_x, _, _):xs) =
  let tr'@((_, _, _, bp2', _, _):_) = drop (|tr| - bp2_x) tr -- go throught bp2_
  in findLastUnapplied (drop (bp2_x - bp2') tr')             -- go throught bp2_ 
                                                             -- again and rec call
findLastUnapplied tr@((ULApp _):xs) = |tr|
findLastUnapplied tr@((ULVar _ , _, _, bp2_x, _):xs) =
  findLastUnapplied (drop (|tr| - bp2_x) tr)                 -- go throught bp2_ again
                                                             -- and rec call

computeBI e i = case e of
  (BVar)    -> findDynamicBinder z (drop (|tr| - i) tr)      -- drop extra elements and
                                                             -- find binder
                                                             -- to find dynamic binder
                                                             -- strongly follow bp4_ till
                                                             -- reach binder
  (FVar)    -> 0
  otherwise -> i
\end{minted}

\begin{landscape}

\subsection{Examples}
Backpointers colors: {\color{red}{bp2}} --- red; {\color{blue}{bp3}} --- blue; {\color{green}{bp4}} --- green;\\
{\color{blue}{Blue tokens}} --- (FVar) or (BVar) where head linear reduction got a stuck, thus, finding unfinished application was called.

\subsubsection{mult three two}
$three\ =\ \lambda a . \lambda q . a @_6 (a @_7 (a @_8 q))$\\
$two\ \ \ =\ \lambda d . \lambda e . d @_9 (d @_10 e)$\\
$mult\ =\ \lambda m . \lambda n . \lambda s . \lambda z . (m @_4 (n @_5 s)) @_3 z$\\
$mult\_3\_2 = (mult @_2 three) @_1 two$\\
\textbf{NB}: in this example there is no difference between bp3\_ and bp2\_, thus, bp\_3 is omitted
\begin{enumerate}
\item
\[\tikzmark{1}{$@_1$}\]
\item
\[\tikzmark{1}{$@_1$}\ \ \tikzmark{2}{$@_2$}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (2.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (2.south) to[bend left] (1.south);}
\end{tikzpicture}
\item
\[\tikzmark{1}{$@_1$}\ \ \tikzmark{2}{$@_2$}\ \ \tikzmark{3}{$\lambda m$}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (2.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (2.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (3.north) to[bend right] (2.north);}
  \color{green}{\draw[->] (3.south) to[bend left] (2.south);}
\end{tikzpicture}
\item
\[\tikzmark{1}{$@_1$}\ \ \tikzmark{2}{$@_2$}\ \ \tikzmark{3}{$\lambda m$}\ \ \tikzmark{4}{$\lambda n$}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (2.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (2.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (3.north) to[bend right] (2.north);}
  \color{green}{\draw[->] (3.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (4.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (4.south) to[bend left] (3.south);}
\end{tikzpicture}
\item
\[\tikzmark{1}{$@_1$}\ \ \tikzmark{2}{$@_2$}\ \ \tikzmark{3}{$\lambda m$}\ \ \tikzmark{4}{$\lambda n$}\ \ \tikzmark{5}{$\lambda s$}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (2.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (2.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (3.north) to[bend right] (2.north);}
  \color{green}{\draw[->] (3.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (4.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (4.south) to[bend left] (3.south);}
  \color{green}{\draw[->] (5.south) to[bend left] (4.south);}
\end{tikzpicture}
\item
\[\tikzmark{1}{$@_1$}\ \ \tikzmark{2}{$@_2$}\ \ \tikzmark{3}{$\lambda m$}\ \ \tikzmark{4}{$\lambda n$}\ \ \tikzmark{5}{$\lambda s$}\ \ \tikzmark{6}{$\lambda z$}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (2.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (2.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (3.north) to[bend right] (2.north);}
  \color{green}{\draw[->] (3.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (4.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (4.south) to[bend left] (3.south);}
  \color{green}{\draw[->] (5.south) to[bend left] (4.south);}
  \color{green}{\draw[->] (6.south) to[bend left] (5.south);}
\end{tikzpicture}
\item
\[\tikzmark{1}{$@_1$}\ \ \tikzmark{2}{$@_2$}\ \ \tikzmark{3}{$\lambda m$}\ \ \tikzmark{4}{$\lambda n$}\ \ \tikzmark{5}{$\lambda s$}\ \ \tikzmark{6}{$\lambda z$}\ \ \tikzmark{7}{$@_3$}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (2.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (2.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (3.north) to[bend right] (2.north);}
  \color{green}{\draw[->] (3.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (4.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (4.south) to[bend left] (3.south);}
  \color{green}{\draw[->] (5.south) to[bend left] (4.south);}
  \color{green}{\draw[->] (6.south) to[bend left] (5.south);}
  \color{green}{\draw[->] (7.south) to[bend left] (6.south);}
\end{tikzpicture}
\item
\[\tikzmark{1}{$@_1$}\ \ \tikzmark{2}{$@_2$}\ \ \tikzmark{3}{$\lambda m$}\ \ \tikzmark{4}{$\lambda n$}\ \ \tikzmark{5}{$\lambda s$}\ \ \tikzmark{6}{$\lambda z$}\ \ \tikzmark{7}{$@_3$}\ \ \tikzmark{8}{$@_4$}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (2.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (2.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (3.north) to[bend right] (2.north);}
  \color{green}{\draw[->] (3.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (4.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (4.south) to[bend left] (3.south);}
  \color{green}{\draw[->] (5.south) to[bend left] (4.south);}
  \color{green}{\draw[->] (6.south) to[bend left] (5.south);}
  \color{green}{\draw[->] (7.south) to[bend left] (6.south);}
  \color{red}{\draw[->] (8.north) to[bend right] (7.north);}
  \color{green}{\draw[->] (8.south) to[bend left] (7.south);}
\end{tikzpicture}
\item $\cdots$
\item
\[\tikzmark{1}{$@_1$}\ \tikzmark{2}{$@_2$}\ \tikzmark{3}{$\lambda m$}\ \tikzmark{4}{$\lambda n$}\ \tikzmark{5}{$\lambda s$}\ \tikzmark{6}{$\lambda z$}\ \tikzmark{7}{$@_3$}\ \tikzmark{8}{$@_4$}\ \tikzmark{9}{$m$}\ \tikzmark{10}{$\lambda a$}\ \tikzmark{11}{$\lambda q$}\ \tikzmark{12}{$@_6$}\ \tikzmark{13}{$a$}\ \tikzmark{14}{$@_5$}\ \tikzmark{15}{$n$}\ \tikzmark{16}{$\lambda d$}\ \tikzmark{17}{$\lambda e$}\ \tikzmark{18}{$@_9$}\ \tikzmark{19}{$d$}\ \color{blue}{\tikzmark{20}{$s$}}\ \color{black}{\tikzmark{21}{$@_{10}$}}\ \tikzmark{22}{$d$}\ \color{blue}{\tikzmark{23}{$s$}}\ \color{black}{\tikzmark{24}{$e$}}\ \tikzmark{25}{$@_7$}\ \tikzmark{26}{$a$}\ \tikzmark{27}{$@_5$}\ \tikzmark{28}{$n$}\ \tikzmark{29}{$\lambda d$}\ \tikzmark{30}{$\lambda e$}\ \tikzmark{31}{$@_9$}\ \tikzmark{32}{$d$}\ \color{blue}{\tikzmark{33}{$s$}}\ \color{black}{\tikzmark{34}{$@_{10}$}}\ \tikzmark{35}{$d$}\ \color{blue}{\tikzmark{36}{$s$}}\ \color{black}{\tikzmark{37}{$e$}}\ \tikzmark{38}{$@_8$}\ \tikzmark{39}{$a$}\ \tikzmark{40}{$@_5$}\ \tikzmark{41}{$n$}\ \tikzmark{42}{$\lambda d$}\ \tikzmark{43}{$\lambda e$}\ \tikzmark{44}{$@_9$}\ \tikzmark{45}{$d$}\ \color{blue}{\tikzmark{46}{$s$}}\ \color{black}{\tikzmark{47}{$@_{10}$}}\ \tikzmark{48}{$d$}\ \color{blue}{\tikzmark{49}{$s$}}\ \color{black}{\tikzmark{50}{$e$}}\ \tikzmark{51}{$q$}\ \color{blue}{\tikzmark{52}{$z$}}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (2.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (2.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (3.north) to[bend right] (2.north);}
  \color{green}{\draw[->] (3.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (4.north) to[bend right] (1.north);}
  \color{green}{\draw[->] (4.south) to[bend left] (3.south);}
  \color{green}{\draw[->] (5.south) to[bend left] (4.south);}
  \color{green}{\draw[->] (6.south) to[bend left] (5.south);}
  \color{green}{\draw[->] (7.south) to[bend left] (6.south);}
  \color{red}{\draw[->] (8.north) to[bend right] (7.north);}
  \color{green}{\draw[->] (8.south) to[bend left] (7.south);}
  \color{red}{\draw[->] (9.north) to[bend right] (8.north);}
  \color{green}{\draw[->] (9.south) to[bend left] (3.south);}
  \color{red}{\draw[->] (10.north) to[bend right] (8.north);}
  \color{green}{\draw[->] (10.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (11.north) to[bend right] (7.north);}
  \color{green}{\draw[->] (11.south) to[bend left] (10.south);}
  \color{green}{\draw[->] (12.south) to[bend left] (11.south);}
  \color{red}{\draw[->] (13.north) to[bend right] (12.north);}
  \color{green}{\draw[->] (13.south) to[bend left] (10.south);}
  \color{red}{\draw[->] (14.north) to[bend right] (12.north);}
  \color{green}{\draw[->] (14.south) to[bend left] (8.south);}
  \color{red}{\draw[->] (15.north) to[bend right] (14.north);}
  \color{green}{\draw[->] (15.south) to[bend left] (4.south);}
  \color{red}{\draw[->] (16.north) to[bend right] (14.north);}
  \color{green}{\draw[->] (16.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (17.north) to[bend right] (12.north);}
  \color{green}{\draw[->] (17.south) to[bend left] (16.south);}
  \color{green}{\draw[->] (18.south) to[bend left] (17.south);}
  \color{red}{\draw[->] (19.north) to[bend right] (18.north);}
  \color{green}{\draw[->] (19.south) to[bend left] (16.south);}
  \color{red}{\draw[->] (20.north) to[bend right] (18.north);}
  \color{green}{\draw[->] (20.south) to[bend left] (5.south);}
  \color{green}{\draw[->] (21.south) to[bend left] (18.south);}
  \color{red}{\draw[->] (22.north) to[bend right] (21.north);}
  \color{green}{\draw[->] (22.south) to[bend left] (16.south);}
  \color{red}{\draw[->] (23.north) to[bend right] (21.north);}
  \color{green}{\draw[->] (23.south) to[bend left] (5.south);}
  \color{green}{\draw[->] (24.south) to[bend left] (17.south);}
  \color{green}{\draw[->] (25.south) to[bend left] (12.south);}
  \color{red}{\draw[->] (26.north) to[bend right] (25.north);}
  \color{green}{\draw[->] (26.south) to[bend left] (10.south);}
  \color{red}{\draw[->] (27.north) to[bend right] (25.north);}
  \color{green}{\draw[->] (27.south) to[bend left] (8.south);}
  \color{red}{\draw[->] (28.north) to[bend right] (27.north);}
  \color{green}{\draw[->] (28.south) to[bend left] (4.south);}
  \color{red}{\draw[->] (29.north) to[bend right] (27.north);}
  \color{green}{\draw[->] (29.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (30.north) to[bend right] (25.north);}
  \color{green}{\draw[->] (30.south) to[bend left] (29.south);}
  \color{green}{\draw[->] (31.south) to[bend left] (30.south);}
  \color{red}{\draw[->] (32.north) to[bend right] (31.north);}
  \color{green}{\draw[->] (32.south) to[bend left] (29.south);}
  \color{red}{\draw[->] (33.north) to[bend right] (31.north);}
  \color{green}{\draw[->] (33.south) to[bend left] (5.south);}
  \color{green}{\draw[->] (34.south) to[bend left] (31.south);}
  \color{red}{\draw[->] (35.north) to[bend right] (34.north);}
  \color{green}{\draw[->] (35.south) to[bend left] (29.south);}
  \color{red}{\draw[->] (36.north) to[bend right] (34.north);}
  \color{green}{\draw[->] (36.south) to[bend left] (30.south);}
  \color{green}{\draw[->] (37.south) to[bend left] (30.south);}
  \color{green}{\draw[->] (38.south) to[bend left] (25.south);}
  \color{red}{\draw[->] (39.north) to[bend right] (38.north);}
  \color{green}{\draw[->] (39.south) to[bend left] (10.south);}
  \color{red}{\draw[->] (40.north) to[bend right] (38.north);}
  \color{green}{\draw[->] (40.south) to[bend left] (8.south);}
  \color{red}{\draw[->] (41.north) to[bend right] (40.north);}
  \color{green}{\draw[->] (41.south) to[bend left] (4.south);}
  \color{red}{\draw[->] (42.north) to[bend right] (40.north);}
  \color{green}{\draw[->] (42.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (43.north) to[bend right] (38.north);}
  \color{green}{\draw[->] (43.south) to[bend left] (42.south);}
  \color{green}{\draw[->] (44.south) to[bend left] (43.south);}
  \color{red}{\draw[->] (45.north) to[bend right] (44.north);}
  \color{green}{\draw[->] (45.south) to[bend left] (42.south);}
  \color{red}{\draw[->] (46.north) to[bend right] (44.north);}
  \color{green}{\draw[->] (46.south) to[bend left] (5.south);}
  \color{green}{\draw[->] (47.south) to[bend left] (44.south);}
  \color{red}{\draw[->] (48.north) to[bend right] (47.north);}
  \color{green}{\draw[->] (48.south) to[bend left] (42.south);}
  \color{red}{\draw[->] (49.north) to[bend right] (47.north);}
  \color{green}{\draw[->] (49.south) to[bend left] (5.south);}
  \color{green}{\draw[->] (50.south) to[bend left] (43.south);}
  \color{green}{\draw[->] (51.south) to[bend left] (11.south);}
  \color{green}{\draw[->] (52.south) to[bend left] (6.south);}
\end{tikzpicture}
\\ \\ \\ \\ \\ \\ 
\end{enumerate}



\subsubsection{NPR example}
$R \ = \ g\ @_{11}\ (\lambda n . n)$\\
$P \ = \ \lambda f . \lambda y . f @_7 ((g @_8 (\lambda b . b)) @_9 y)$\\
$N \ = \ \lambda h . \lambda z . ((h @_1 (\lambda x . ((h @_2 (\lambda q . x)) @_3 a))) @_4 (z @_5 a))$\\
$ex \ = \ (N @_6 P) @_{10} Q$\\
\textbf{NB}: tokens with different bp2\_ and bp3\_ are {\color{violet}{colored}}.

\[\tikzmark{1}{$@_{10}$}\ \ \tikzmark{2}{$@_6$}\ \ \tikzmark{3}{$\lambda h$}\ \ \tikzmark{4}{$\lambda z$}\ \ \tikzmark{5}{$@_4$}\ \ \tikzmark{6}{$@_1$}\ \ \tikzmark{7}{$h$}\ \ \tikzmark{8}{$\lambda f$}\ \ \tikzmark{9}{$\lambda y$}\ \ \tikzmark{10}{$@_{7}$}\ \ \tikzmark{11}{$f$}\ \ \tikzmark{12}{$\lambda x$}\ \ \tikzmark{13}{$@_3$}\ \ \tikzmark{14}{$@_2$}\ \ \tikzmark{15}{$h$}\ \ \tikzmark{16}{$\lambda f$}\ \ \tikzmark{17}{$\lambda y$}\ \ \tikzmark{18}{$@_7$}\ \ \tikzmark{19}{$f$}\ \ \tikzmark{20}{$\lambda q$}\ \ \tikzmark{21}{$x$}\ \ \tikzmark{22}{$@_9$}\ \ \tikzmark{23}{$@_8$}\ \ \color{blue}{\tikzmark{24}{$g$}} \ \ {\color{violet}{\tikzmark{25}{$\lambda b$}}}\ \ \color{blue}{\tikzmark{26}{$b$}}\ \ \color{black}{\tikzmark{27}{$y$}}\ \ \tikzmark{28}{$@_5$}\ \ \tikzmark{29}{$z$}\ \ \tikzmark{30}{$@_{11}$}\ \ \color{blue}{\tikzmark{31}{$g$}}\ \ {\color{violet}{\tikzmark{32}{$\lambda n$}}}\ \ \color{blue}{\tikzmark{33}{$n$}\ \ \tikzmark{34}{$a$}}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (2.north) to[bend right] (1.north);}
  \color{blue}{\draw[->] (2.south west) to[bend left] (1.south east);}
  \color{green}{\draw[->] (2.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (3.north) to[bend right] (2.north);}
  \color{blue}{\draw[->] (3.south west) to[bend left] (2.south east);}
  \color{green}{\draw[->] (3.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (4.north) to[bend right] (1.north);}
  \color{blue}{\draw[->] (4.south west) to[bend left] (1.south east);}
  \color{green}{\draw[->] (4.south) to[bend left] (3.south);}
  \color{green}{\draw[->] (5.south) to[bend left] (4.south);}
  \color{red}{\draw[->] (6.north) to[bend right] (5.north);}
  \color{blue}{\draw[->] (6.south west) to[bend left] (5.south east);}
  \color{green}{\draw[->] (6.south) to[bend left] (5.south);}
  \color{red}{\draw[->] (7.north) to[bend right] (6.north);}
  \color{blue}{\draw[->] (7.south west) to[bend left] (6.south east);}
  \color{green}{\draw[->] (7.south) to[bend left] (3.south);}
  \color{red}{\draw[->] (8.north) to[bend right] (6.north);}
  \color{blue}{\draw[->] (8.south west) to[bend left] (6.south east);}
  \color{green}{\draw[->] (8.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (9.north) to[bend right] (5.north);}
  \color{blue}{\draw[->] (9.south west) to[bend left] (5.south east);}
  \color{green}{\draw[->] (9.south) to[bend left] (8.south);}
  \color{green}{\draw[->] (10.south) to[bend left] (9.south);}
  \color{red}{\draw[->] (11.north) to[bend right] (10.north);}
  \color{blue}{\draw[->] (11.south west) to[bend left] (10.south east);}
  \color{green}{\draw[->] (11.south) to[bend left] (8.south);}
  \color{red}{\draw[->] (12.north) to[bend right] (10.north);}
  \color{blue}{\draw[->] (12.south west) to[bend left] (10.south east);}
  \color{green}{\draw[->] (12.south) to[bend left] (6.south);}
  \color{green}{\draw[->] (13.south) to[bend left] (12.south);}
  \color{red}{\draw[->] (14.north) to[bend right] (13.north);}
  \color{blue}{\draw[->] (14.south west) to[bend left] (13.south east);}
  \color{green}{\draw[->] (14.south) to[bend left] (13.south);}
  \color{red}{\draw[->] (15.north) to[bend right] (14.north);}
  \color{blue}{\draw[->] (15.south west) to[bend left] (14.south east);}
  \color{green}{\draw[->] (15.south) to[bend left] (3.south);}
  \color{red}{\draw[->] (16.north) to[bend right] (14.north);}
  \color{blue}{\draw[->] (16.south west) to[bend left] (14.south east);}
  \color{green}{\draw[->] (16.south) to[bend left] (2.south);}
  \color{red}{\draw[->] (17.north) to[bend right] (13.north);}
  \color{blue}{\draw[->] (17.south west) to[bend left] (13.south east);}
  \color{green}{\draw[->] (17.south) to[bend left] (16.south);}
  \color{green}{\draw[->] (18.south) to[bend left] (17.south);}
  \color{red}{\draw[->] (19.north) to[bend right] (18.north);}
  \color{blue}{\draw[->] (19.south west) to[bend left] (18.south east);}
  \color{green}{\draw[->] (19.south) to[bend left] (16.south);}
  \color{red}{\draw[->] (20.north) to[bend right] (18.north);}
  \color{blue}{\draw[->] (20.south west) to[bend left] (18.south east);}
  \color{green}{\draw[->] (20.south) to[bend left] (14.south);}
  \color{green}{\draw[->] (21.south) to[bend left] (12.south);}
  \color{green}{\draw[->] (22.south) to[bend left] (10.south);}
  \color{red}{\draw[->] (23.north) to[bend right] (22.north);}
  \color{blue}{\draw[->] (23.south west) to[bend left] (22.south east);}
  \color{green}{\draw[->] (23.south) to[bend left] (22.south);}
  \color{red}{\draw[->] (24.north) to[bend right] (23.north);}
  \color{blue}{\draw[->] (24.south west) to[bend left] (23.south east);}
  \color{red}{\draw[->] (25.north) to[bend right] (23.north);}
  \color{blue}{\draw[->] (25.south west) to[bend left] (20.south east);}
  \color{green}{\draw[->] (25.south) to[bend left] (23.south);}
  \color{red}{\draw[->] (26.north) to[bend right] (22.north);}
  \color{blue}{\draw[->] (26.south west) to[bend left] (22.south east);}
  \color{green}{\draw[->] (26.south) to[bend left] (25.south);}
  \color{green}{\draw[->] (27.south) to[bend left] (9.south);}
  \color{green}{\draw[->] (28.south) to[bend left] (5.south);}
  \color{red}{\draw[->] (29.north) to[bend right] (28.north);}
  \color{blue}{\draw[->] (29.south west) to[bend left] (28.south east);}
  \color{green}{\draw[->] (29.south) to[bend left] (4.south);}
  \color{red}{\draw[->] (30.north) to[bend right] (28.north);}
  \color{blue}{\draw[->] (30.south west) to[bend left] (28.south east);}
  \color{green}{\draw[->] (30.south) to[bend left] (1.south);}
  \color{red}{\draw[->] (31.north) to[bend right] (30.north);}
  \color{blue}{\draw[->] (31.south west) to[bend left] (30.south east);}
  \color{red}{\draw[->] (32.north) to[bend right] (30.north);}
  \color{green}{\draw[->] (32.south) to[bend left] (30.south);}
  \color{red}{\draw[->] (33.north) to[bend right] (28.north);}
  \color{blue}{\draw[->] (33.south west) to[bend left] (28.south east);}
  \color{green}{\draw[->] (33.south) to[bend left] (32.south);}
\end{tikzpicture}
\end{landscape}


\subsection{TODO}
\begin{enumerate}
\item proof correctness and residual term (normalized) reconstruction
\end{enumerate}


\newpage
\section{LLL}

\subsection{$\Lambda^{\textit{SimplyUntyped}} \ \rightarrow$ LLL}
This section contains a description of \textbf{LLL}-code and process of translating $\Lambda^{\textit{SimplyUntyped}}$ to this LLL. Generally speaking, types is only used to generate by simply-typed lambda expression a correct $\eta$-long form. For the sake of brevity, we will assume that term is given in a $\eta$-long form at once.
I.e. we will consider the following transformation: $\Lambda^{\eta-long}\ \rightarrow$ LLL.

Let \textbf{M} be a lambda expression, \textbf{token} be a common alias for arbitrary M-subexpression. More precisely, token is a \textit{named M subexpression} that can has one of the following forms:
\begin{itemize}
\item \textbf{(Lam)} $\lambda\ x\ .\ M$;
\item \textbf{(Var)} $x\ Ms$ : \textbf{(BVar)} or \textbf{(FVar)}; ((BVar) set of bound variables can be statically precomputed before running LLL-generator);
\item \textbf{(App)} $@\ Ms$ --- a long-application operator.
\end{itemize}

\textbf{LLL} is a low-level language that is used as intermediate representation for traversal generator. This means that by given $\Lambda^{\eta-long}$ expression we will generate an LLL-code that is a semantic (i.e. it determines "how to generate traversal for this expression"). Thus, traversal generation is splitted into two steps:\\
1.$\Lambda^{\eta-long}\ \rightarrow \ LLL$\\
2.$LLL\ \rightarrow \ traversal$\\
The main advantage of such approach is that
programs on LLL have a linear length (with respect to the input lambda term) while thraversal would be generated by them can be much larger.\\
I.e. LLL-program = $\mathcal{C}\llbracket M \rrbracket$, where $\abs{\mathcal{C}\llbracket M \rrbracket}$ = $\mathcal{O}(\abs{M})$.

\begin{enumerate}
\item LLL-program has the following structure:
  \begin{enumerate}
  \item For each token we generate \textbf{only one} function that strongly follows the pattern:
    \begin{minted}{scheme}
      (define (<token name> t) <body>)
    \end{minted}
    {\color{red}where}
    \begin{itemize}
    \item \textit{t} is a current traversal,
    \item <token name> is just a unique token identifier,
    \item <body> is a command of the following form:
      \begin{itemize}
      \item call the next tokens-handler when the next token can be uniquely identified (\textit{i.e. statically known}) by traversal generator rules (i.e. $\lambda$ and $@$(long application) nodes)
        \begin{minted}{scheme}
(<next token name> (cons `(,<current token name> ,<backpointer>) t))
        \end{minted}
      \item call auxiliary function \textit{CGOTO}, otherwise:
        \begin{minted}{scheme}
          (CGOTO t i)
        \end{minted}
        {\color{red}where} i is a number that corresponds to (BVar) location in its binder.\\
        (ex: $\lambda x y$ then x has i == 1, y has i == 2)
      \end{itemize}
    \end{itemize}
  \item Auxiliary \textit{CGOTO} function.\\
    This function is statically generated at the begin of LLL-generation process. In some sense this is a pattern matcher function that by given traversal and number identifies the next token function to be called. In other words, it by current traversal state desides "where to go next"; the set of possible "next tokens" is \textit{statically precomputed} for each token (this set is uniquely defined by term-tree).\\
    This function is \textit{static up to one dynamic parameter --- current traversal}.
  \item Auxiliary \textit{FQ} function that computes back poiner for each token following rules described in [cite to Ong's paper].
  \end{enumerate}
  
\item Token function generation.\\Token function correcponds to \textit{semantic} for traversal generation rules. It strongly follows rules that is described in [cite to Ong's paper]. I.e.:
  \begin{itemize}
  \item \textbf{(Lam)}: $T\ \lambda\ args\ .\ M$ where T is a token alias:
    \begin{minted}{haskell}
    case M of
      TN @    N -> (cons `(define (T t) (TN (cons (ln, 0) t)))
                         (generate LLL-code for N))
      TN bvar N -> (cons `(define (T t) (TN (cons (TN, (FQ binder t)) t)))
                         (generate LLL-code for N))
      TN fvar N -> (cons `(define (T t) (TN (cons (TN, 1) t)))
                         (generate LLL-code for N))
    \end{minted}
  \item \textbf{(FVar)} $T\ x\ M$ where T is a token-alias, M be a list of arguments:
    \begin{minted}{scheme}
      (if (null? M)
        `((define (T t) (cons 'END-OF-TRAVERSAL t)))
        (let ([new_l (car M)])
          (cons `(define (,l t) (,new_l (cons (,new_l, |t|)) t))
                (generate LLL-code for new_l))))
    \end{minted}
    \textbf{NB}: this version generates only one traversal (not a set of raversals). Thus, all the time we chouse the first argument in (FVar)-case.
  \item \textbf{(BVar)} $T\ x\ args$ where T is a token-alias, M be a list of arguments:
    \begin{minted}{scheme}
      (let ([m (binder alias)]
            [i (x-th number in list of binder arduments)])
        (cons `(define (T t) (CGOTO t ,i))
              (forall arg in args generate LLL-code)))
    \end{minted}
  \item \textbf{(App)} $T\ @\ M$ where T is a token-alias, M be a list of arguments:
    \begin{minted}{scheme}
      (let ([next_label (car M)])
        (cons `(define (T t) (,next_label (cons (,next_label, |t|) t)))
              ((generate LLL-code for other elements from M))))
    \end{minted}
  \end{itemize}

\item An example.\\
  Let's look at simple example for traversal generator for 'succ' function.
  \begin{itemize}
  \item The named lambda expression for succ function ($\lambda n s z . s (n (s) (z))$ that has a $\eta$-long form \\ $\lambda n s z . s (\lambda . n (\lambda a1 . s (\lambda . a1)) (\lambda . z))$) can be expressed as follows:
    \begin{minted}{scheme}
(define succ
'(A :lambda ()
  (B : s
    ((C :lambda ()
      (D : n ((E :lambda (a1) (F : s ((G :lambda () (H : a1())))))
              (I :lambda () (J : z ()))))))
            )))
    \end{minted}
  \item Generated LLL-program:
    \begin{minted}{scheme}
; CGOTO function
(define (CGOTO t i)
  (let ((q (- (cadar t) 1))) (CGOTO1 (caar (pfx q t)) t q i)))
(define (CGOTO1 have t p i)
  ; is token corresponds to a free varibale or not
  (if (not (member have '(F J D B)))
    ; 'have' doesn't corresponds to a free variable
    (if (equal? have 'B)
      (if (equal? i 1) (C (cons (list 'C p) t)) (error 'GOTO:ERROR))
      (if (equal? have 'D)
        (if (equal? i 2)
          (error 'IERROR)
          (if (equal? i 1) (E (cons (list 'E p) t)) (error 'GOTO:ERROR)))
        (if (equal? have 'F)
          (if (equal? i 1) (G (cons (list 'G p) t)) (error 'GOTO:ERROR))
          (error 'ERROR))))
    ; FVar --> end of traversal
    (cons `EOT t)))

; calculating backpointer
(define (FQ have t)
  (letrec ((f
            (lambda (t0)
              (if (equal? have (caar t0))
                (length t0)
                (let ((bp (cadar t0))) (f (pfx (- bp 1) t)))))))
    (f t)))

; auxiliary functions
(define (pfx n t) (reverse (take n (reverse t))))
(define (take n xs)
  (if (equal? n 0) '() (cons (car xs) (take (- n 1) (cdr xs)))))

; token-functions
(define (A t) (B (cons (list 'B 1) t)))
(define (B t) (C (cons (list 'C (length t)) t)))
(define (C t) (D (cons (list 'D 1) t)))
(define (D t) (E (cons (list 'E (length t)) t)))
(define (E t) (F (cons (list 'F 1) t)))
(define (F t) (G (cons (list 'G (length t)) t)))
(define (G t) (H (cons (list 'H (FQ 'E t)) t)))
(define (H t) (CGOTO t 1))

; main function
(reverse (A '((A 0))))
      \end{minted}
  \item Generated traversal
    \begin{minted}{scheme}
'((A 0) (B 1) (C 2) (D 1) (E 4) (F 1) (G 6) (H 5) EOT)
      \end{minted}
      Pretty-print №1:
\[\tikzmark{A}{$A$}\ \ \tikzmark{B}{$B$}\ \ \tikzmark{C}{$C$}\ \ \tikzmark{D}{$D$}\ \ \tikzmark{E}{$E$}\ \ \tikzmark{F}{$F$}\ \ \tikzmark{G}{$G$}\ \ \tikzmark{H}{$H$}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (B.north) to[bend right] (A.north);}
  \color{red}{\draw[->] (C.north) to[bend right] (B.north);}
  \color{red}{\draw[->] (D.north) to[bend right] (A.north);}
  \color{red}{\draw[->] (E.north) to[bend right] (D.north);}
  \color{red}{\draw[->] (F.north) to[bend right] (A.north);}
  \color{red}{\draw[->] (G.north) to[bend right] (F.north);}
  \color{red}{\draw[->] (H.north) to[bend right] (E.north);}
\end{tikzpicture}
      Pretty-print №2:
\[\tikzmark{A}{$\lambda$}\ \ \tikzmark{B}{$s$}\ \ \tikzmark{C}{$\lambda$}\ \ \tikzmark{D}{$n$}\ \ \tikzmark{E}{$\lambda a1$}\ \ \tikzmark{F}{$s$}\ \ \tikzmark{G}{$\lambda$}\ \ \tikzmark{H}{$a1$}\]
\begin{tikzpicture}[remember picture,overlay]
  \color{red}{\draw[->] (B.north) to[bend right] (A.north);}
  \color{red}{\draw[->] (C.north) to[bend right] (B.north);}
  \color{red}{\draw[->] (D.north) to[bend right] (A.north);}
  \color{red}{\draw[->] (E.north) to[bend right] (D.north);}
  \color{red}{\draw[->] (F.north) to[bend right] (A.north);}
  \color{red}{\draw[->] (G.north) to[bend right] (F.north);}
  \color{red}{\draw[->] (H.north) to[bend right] (E.north);}
\end{tikzpicture}
  \end{itemize}

\item Several comments:
  \begin{enumerate}
  \item LLL-generator is written on Scheme. Thus, we can use UNMIX [cite to Romanenko paper?] to specialize it.\\
    I.e. generator (or compiler) is a function $\mathcal{C}\llbracket \ \rrbracket \ :\ \Lambda\ \rightarrow\ LLL$ that preserves semantics.\\
    $\mathcal{C}\llbracket M \rrbracket \ =\ p$ where $p \in LLL-programs$\\
    Specialized program: UNMIX [$\mathcal{C}$ $(\lambda -expression)$] = $p_{opt}$ such that\\
    $\forall p \in LLL-programs \ \llbracket p \rrbracket \ =\ \llbracket p_{opt} \rrbracket$.\\
    \textbf{Example}:\\
    We expect that specialization will roll up all call that can be combined statically. I.e. for example, LLL-program for \textit{succ} instead of
    \begin{minted}{scheme}
(define (A t) (B (cons (list 'B 1) t)))
(define (B t) (C (cons (list 'C (length t)) t)))
(define (C t) (D (cons (list 'D 1) t)))
(define (D t) (E (cons (list 'E (length t)) t)))
(define (E t) (F (cons (list 'F 1) t)))
(define (F t) (G (cons (list 'G (length t)) t)))
(define (G t) (H (cons (list 'H (FQ 'E t)) t)))
(define (H t) (CGOTO t 1))
(reverse (A `((A 0))))
    \end{minted}
    will be trasformed (i.e. specialized) to something like:
    \begin{minted}{scheme}
(define (H t) (CGOTO t 1))
(reverse (H '((G 5) (F 1) (E 3) (D 1) (C 2) (B 1) (A 0))))
    \end{minted}
    following the fact that token functions for A, B, C, D, E, F, G can be computed statically;
  \item LLL-programs are \textit{linear-bounded}: $\exists\ m,n\ \in \mathbb{N}\ \forall\ M\ \in \Lambda^{\eta-long}\ :\ \abs{\mathcal{C}(M)}\ =\ m\cdot\abs{M}+n$;
  \item We expect that LLL can be used to express other evaluation strategies: call-by-value, call-by-need, $\cdots$;
  \item LLL can be extended to NLLL (Nondeterminictic LLL) that would be able to generate a whole set of traversals (see laster sections);
  \item LLL can be extended to games between data and program (see laster sections);
  \item We also expect that LLL can be extended to $\Lambda^{Untyped}$ and more expressive and powerfull languages.
  \end{enumerate}
\end{enumerate}


\newpage
\subsection{\textbf{NLLL}}
This section contains \textbf{NLLL} code description. In process of generating traversal from a term in $\eta$-long form each step is determinictic except one: free variable occurence. Then we faced with free variable our traversal splits on a set of traversals which capacity is equal to the number of free variable arguments. To be able to hadle above situation we extended our LLL to \textbf{NLLL}. It has ony one new operator : \textit{\textbf{choose}}. \textit{choose} is an operator of nondeterminictic choise between its branches. \\ \textbf{Ex}: \mintinline{scheme}{(define (D t) (choose (E ...) (I ...)}

We also need to change a (FVar) rule (from LLL) to be able to generate token function for all arguments.

Our \textit{succ} example now:
\begin{minted}[escapeinside=||]{scheme}
; auxiliary functions is ommited (they are exactly the same)

; token-functions
(define (A t) (B (cons (list 'B 1) t)))
(define (B t) (C (cons (list 'C (length t)) t)))
(define (C t) (D (cons (list 'D 1) t)))

;| {\color{red}{}changed free variable token D} |
(define (D t) (choose 
  (E (cons (list 'E (length t)) t))
  (I (cons (list 'I (length t)) t))))(define (E t) (F (cons (list 'F 1) t)))

(define (F t) (G (cons (list 'G (length t)) t)))
(define (G t) (H (cons (list 'H (FQ 'E t)) t)))
(define (H t) (CGOTO t 1))

;| {\color{red}{} new tokens (from the second D's argument)} |
(define (I t) (J (cons (list 'J 1) t)))
(define (J t) (cons 'END-OF-TRAVERSAL t))

; main function
(reverse (A '((A 0))))
\end{minted}

\textbf{NB}: Obviously NLLL-code remaines linear-dependence from the input term;


\newpage
\subsection{Games in \textbf{LLL}}
In previous sections \textit{LLL} has been bescribed. We claim that LLL is compositional and is able to independently generate low-level code for \textbf{program} and \textbf{data}. More preciesly, having a program \textbf{p} and data \textbf{$d_1, d_2, \dots, d_n$} we are able to generate LLL-code for each of them which is being combined is able to generate traversal for $p\ d_1\ d_2\ \dots\ d_n$:\\
$\mathcal{C}\llbracket p \rrbracket\ =\ p_{opt}$\\
$\mathcal{C}\llbracket d_1 \rrbracket\ =\ d_{1_{opt}}$\\
$\cdots$\\
$\mathcal{C}\llbracket d_n \rrbracket\ =\ d_{n_{opt}}$\\
such that: 
$\llbracket \llbracket p_1 \rrbracket\ \ d_1 \cdots \ d_n \rrbracket=\ \llbracket \llbracket p_{opt} \rrbracket\ d_{1_{opt}}\cdots\ d_{n_{opt}}\rrbracket$

In other words, we generate LLL-code separatly for each program part which will communicate with each other while LLL-code is being executed. Let's call \textbf{process} an execution of a part of LLL-code that corresponds to either program or one of data is provided.

We introduce two new operators that is used by processes to communicate and transfer a control flow between each other:
\begin{enumerate}
\item \textbf{PLAY P T} that means \textit{sent a token T to process P and goto next instruction};
\item \textbf{?p (t1 $\dots$ tn)} that means \textit{transfer the control flow to the process $p$ and wait; when the control returns to current process check message queue from process P and chose the corresponding label};
\item For example,\\
\textbf{D: ?1 (E, M);} transfers the control flow to data 1 and wait for some answer (1(i.e. Goto E), 2(i.e. Goto M) or 0 ("nothing", i.e. go to the next command)).
\end{enumerate}

For now program is a term in $\eta$-long form with subtree that corresponds to data part replaced by indexed keyword $data$. In other words, program is a term in $\eta$-long form that has plugs instead of real data.

For example, let consider a well-known successor function ofr Church numerals $\lambda n s z\ .\ s @ ((n @ s) @ z)$ that (as we seen before) has the following $\eta$-long form:\\
$\lambda\ .\ @\  (\lambda n s z\ .\ s\ (\lambda\ .\ n\ (\lambda a_1 . s (\lambda\ .\ a_1))\ z))\\
(\lambda s_1 z_1\ .\ m\ (\lambda a_2\ .\ s_1\ (\lambda\ .\ a_2))\ (\lambda\ .\ z_1))\\
(\lambda z_2\ .\ s_2\ (\lambda\ .\ z_2))\\
(\lambda \ .\ z_3)$\\
where $m,\ s_2,\ z_3$ are free variables. The corresponding tree:

\begin{tikzpicture}[sibling distance=15mm, level distance=12mm,
  every node/.style = {shape=rectangle, rounded corners,
    draw, align=center,
    top color=white, bottom color=blue!20}]]
  \node{$\lambda$}
    child[grow=right] { node {$@$}
      child[grow=right] {
        child { node {$\lambda n s z$}
          child[grow=right] { node {$s$}
            child[grow=right] {node {$\lambda$}
              child[grow=right] {node {$n$}
                child[grow=right] {
                  child {node {$\lambda a_1$}
                    child[grow=right] {node {$s$}
                      child[grow=right] {node {$\lambda$} child {node {$a_1$}}}}}
                  child {node {$\lambda$} child[grow=right]{node{$z$}}}}}}}}
        child { node {$\lambda s_1 z_1$}
          child[grow=right] { node {$m$}
            child[grow=right] {
              child[grow=right] { node {$\lambda a_2$}
                child[grow=right] { node {$s_1$}
                  child[grow=right] { node {$\lambda$}
                    child[grow=right] { node {$a_2$}}}}}
              child { node {$\lambda$}
                child[grow=right] { node {$z_1$}}}}}}
        child { node {$\lambda z_2$}
          child[grow=right] { node {$s_2$}
            child[grow=right] { node {$\lambda$}
              child[grow=right] { node {$z_2$} }}}}
        child {node {$\lambda$} child[grow=right] {node {$z_3$}}}
      }
    };
\end{tikzpicture}

Suppose we want number be an unknown data while we generate LLL for function. In this case our tree will looks as follows:

\begin{tikzpicture}[sibling distance=10mm, level distance=10mm,
  every node/.style = {shape=rectangle, rounded corners,
    draw, align=center,
    top color=white, bottom color=blue!20}]]
  \node{$\lambda$}
    child[grow=right] { node {$@$}
      child[grow=right] {
        child { node {$\lambda n s z$}
          child[grow=right] { node {$s$}
            child[grow=right] {node {$\lambda$}
              child[grow=right] {node {$n$}
                child[grow=right] {
                  child {node {$\lambda a_1$}
                    child[grow=right] {node {$s$}
                      child[grow=right] {node {$\lambda$} child {node {$a_1$}}}}}
                  child {node {$\lambda$} child[grow=right]{node{$z$}}}}}}}}
        child { node {{\color{red}$data$}}}
        child { node {$\lambda z_2$}
          child[grow=right] { node {$s_2$}
            child[grow=right] { node {$\lambda$}
              child[grow=right] { node {$z_2$} }}}}
        child {node {$\lambda$} child[grow=right] {node {$z_3$}}}
      }
    };
\end{tikzpicture}

Where {\color{red}$data$} could be an arbitrary Church numeral (in fact, it can be an arbitrary lambda term in $\eta$-long form with respect to types, i.e. a Church numeral $;)$ ). For example, three:

\begin{tikzpicture}[sibling distance=10mm, level distance=10mm,
  every node/.style = {shape=rectangle, rounded corners,
    draw, align=center,
    top color=white, bottom color=blue!20}]]
  \node {$\lambda s_1 z_1$}
    child[grow=right] { node {$s1$}
        child[grow=right] { node {$\lambda$}
          child[grow=right] { node {$s_1$}
            child[grow=right] { node {$\lambda$}
              child[grow=right] { node {$s1$}
                child[grow=right] { node {$\lambda$}
                  child[grow=right] { node {$z1$}}}}}}}};
\end{tikzpicture}

In this case the play between program \textit{succ} and data \textit{tree} is as follows:
\begin{minted}[escapeinside=||]{scheme}
TODO: dialog for succ three
\end{minted}























% \begin{minted}[mathescape]{scheme}
% (define (D t) (choose (E ...) (I ...)
% \end{minted}

\end{document}








