\documentclass[a4paper, 10pt]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage[utf8]{inputenc}%кодировка
\usepackage[russian]{babel}%используем русский и английский языки с переносами
\usepackage{fontspec}
\usepackage{cite}
\usepackage{multirow}
\usepackage{float}
\usepackage{tikz-cd}
\usetikzlibrary{babel}
\usepackage{amssymb }
\usepackage{amsmath}
\usepackage{listings}
\usepackage{cancel}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{calc}
\newcommand{\tikzmark}[3][]{\tikz[remember picture,baseline] \node [inner xsep=0pt,anchor=base,#1](#2) {#3};}

%\usepackage{xcolor}
%\graphicspath{{pictures/}}
%\definecolor{dkgreen}{rgb}{0,0.6,0}
%\definecolor{dred}{rgb}{0.545,0,0}
%\definecolor{dblue}{rgb}{0,0,0.545}
%\definecolor{lgrey}{rgb}{0.9,0.9,0.9}
%\definecolor{gray}{rgb}{0.4,0.4,0.4}
%\definecolor{darkblue}{rgb}{0.0,0.0,0.6}

%\usepackage{pythontex}
%\usepackage{minted}

% for printing trees
\usepackage{verbatim}

%\usepackage[labelformat=empty]{caption}
%\usepackage{fontspec}
%\usepackage{polyglossia}
%\setdefaultlanguage{english}
%\defaultfontfeatures{Ligatures=TeX}
%\setmainfont{CMU Serif}
%\setsansfont{CMU Sans Serif}
%\setmonofont{CMU Typewriter Text}

%\usepackage{stmaryrd}
\usepackage{amsfonts}
\newcommand\abs[1]{\left|#1\right|}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}

\newcommand{\State}[1]{\left<{#1}\right>}
\newcommand{\InContext}[2]{{#1}\left[{#2}\right]}
\newcommand{\RuleNo}[1]{\eqno[\textsc{#1}]}
\newcommand{\Rule}[2]{{#1}\longrightarrow{#2}}

%\usetikzlibrary{calc}

\begin{document}

Everywhere in this notes we will consider a lambda term as a tree.

\section{Head Linear Reduction}

This section introduces the \emph{head linear reduction} (\textbf{HLR}) in a way that
is similar to [?'Danos].
The head linear reduction is a reduction stratagy that performs a linear substitution
by replacing a so called \emph{head variable occurence} (\emph{hoc}) on each step.
\emph{hoc} can be found as a leaf on the left-most path in a tree. If this leaf is not
a variable or represents a free variable then \textbf{HLR} got stuck and results in a
\emph{quasi-head normal form} (\emph{ghn}).

To be more concrete let's present a HLR as the following \textbf{transition system}:
\begin{itemize}
\item A state is a tuple $\langle$ $A[\underline{B}]$; $\Gamma$; $\Delta$ $\rangle$, where
  \begin{itemize}
  \item $A[\underline{B}]$ is a $\lambda$-term $A$ with an underline node $B$;
  \item $\Gamma$ is an environment that binds variables; an environment can be considered
    as a \emph{set}; we will denote environment as follows:
    $$\Gamma \ = \ var \mapsto (t,\ \Gamma_1),\ \Gamma_2$$ where
    $var$ is a variable, $t$ is a $\lambda$-term, $\Gamma_1$ is a stored environment,
    $\Gamma_2$ is a rest of environment $\Gamma$;
  \item $\Delta$ is a stack of pairs $(t_1, \ \Gamma_1)$ where $t_1$ is a $\lambda$-term and
    $\Gamma_1$ is an environment.
    $$\textnormal{Denotation: } \Delta \ = \ (t_1,\ \Gamma_1) \bullet \Delta_1$$
    where $\Delta_1$ is a rest of the stack $\Delta$.
  \end{itemize}
\item The \emph{initial} state is $\langle\ \lambda-term\ with\ underlined\ root;\ \emptyset;\ [\ ]\ \rangle$
  where $\emptyset$ denotes an empty set and $[\ ]$ --- empty stack.
\item The \emph{final} state is $\langle\ A [\underline{x}];\ \Gamma;\ [\ ]\ \rangle$ where
  \begin{itemize}
  \item $A [\underline{x}]$ is a $\lambda$-term with a variable $x$ as an underlined node
  \item $x \not\in \Gamma$
  \end{itemize}
\item Denotation: $\InContext{A_{\xcancel{B}}}{\xcancel{\lambda\ x}\ .\ e}$ ---
  is a term $A$ where subterm $B$  and node ``$\lambda x$'' are crossed over.
\end{itemize}

\subsection{Rules}

$$
\Rule{\State{\InContext{A}{e_1\underline{@}e_2};\;\Gamma;\;\Delta}}
     {\State{\InContext{A}{\underline{e_1}@e_2};\;\Gamma;\;(e_2,\Gamma)\bullet\Delta}}
\RuleNo{App}
$$

$$
\Rule{\State{\InContext{A}{\underline{\lambda x}.e};\;\Gamma;\;[]}}
     {\State{\InContext{A}{\lambda x.\underline{e}};\;\Gamma;\;[]}}
\RuleNo{Lam-Non-Elim}
$$

$$
\Rule{\State{\InContext{A}{\underline{\lambda x}.e};\;\Gamma;\;(B,\Gamma')\bullet\Delta}}
     {\State{\InContext{A_{\xcancel{B}}}{\xcancel{\lambda x}.\underline{e}};\;x \mapsto (B,\Gamma'),\,\Gamma;\;\Delta}}
\RuleNo{Lam-Elim}
$$

$$
\Rule{\State{\InContext{A}{\underline{x}};\;x\mapsto (B,\Gamma'),\,\Gamma;\;\Delta}}
     {\State{\InContext{A}{\underline{B}};\;\Gamma';\;\Delta}}
\RuleNo{BVar}
$$

\subsubsection{Example}

Consider the following input term $(\lambda \ x\ .\ x)\ @\ (\lambda \ y\ .\  y)$.
\begin{align}
  \label{Ex1}
  \langle (\lambda \ x\ .\ x)\ \underline{@}\ (\lambda \ y\ .\  y);\ & \ \emptyset;\ & [\ ] \rangle & \rightarrow^{[App]} \\
  \label{Ex2}
  \langle (\underline{\lambda \ x}\ .\ x)\ @\ (\lambda \ y\ .\  y);\ & \ \emptyset;\ & ((\lambda\ y\ .\ y),\ \emptyset)
  \rangle & \rightarrow^{[Lam-Elim]} \\
  \label{Ex3}
  \langle (\xcancel{\lambda \ x}\ .\ \underline{x})\ \xcancel{@}\ \xcancel{(\lambda \ y\ .\  y)};\ &
  \ x \mapsto ((\lambda\ y\ .\ y),\ \emptyset);\ & [\ ] \rangle & \rightarrow^{[BVar]} \\
  \label{Ex4}
  \langle (\xcancel{\lambda \ x}\ .\ \underline{\lambda \ y}\ . y )\ \xcancel{@}\ \xcancel{(\lambda \ y\ .\  y)};\ &
  \ \emptyset; \ & [\ ] \rangle & \rightarrow^{[Lam-Non-Elim]} \\
  \label{Ex5}
  \langle (\xcancel{\lambda \ x}\ .\ \lambda \ y\ . \underline{y} )\ \xcancel{@}\ \xcancel{(\lambda \ y\ .\  y)};\ &
  \ \emptyset; \ & [\ ] \rangle & \not\rightarrow
\end{align}

\subsection{Correctness proof}
In this section correctness with respect to the \textbf{head reduction} is presented.
To perform that we will define an auxiliary function "\emph{expansion (exp)}".

\paragraph{Expansion function.} 
\emph{exp} by a given transition system state provides a $\lambda$-term.
Informally speaking function \emph{exp} performs head substition of all
variables that are presented in the environments.

\begin{align}
  \label{exp1} exp\; \langle M[\underline{A}];\; \Gamma,\ x \mapsto (B, \Gamma');\; \Delta \rangle
  &= exp\; \langle M[\underline{A}[x / B[\Gamma']]];\; \Gamma;\; \Delta \rangle \\
  \label{exp2} exp\; \langle M_B[\underline{A}];\; \emptyset;\; (B,\Gamma')\bullet\Delta \rangle
  &= exp\; \langle M_{B[\Gamma']}[\underline{A}];\; \emptyset;\; \Delta \rangle\\
  \label{exp3} exp\; \langle M;\; \emptyset;\; [\ ] \rangle &= M' \\
  \textnormal{where } B[\Gamma'] &= exp\; \langle \underline{B};\; \Gamma';\; [\ ] \rangle \\
  & M' \textnormal{ is a term } M \textnormal{ where all nodes that are crossed over are crosed out }
\end{align}

Note that \eqref{exp1} substitudes term $B[\Gamma']$ instead of all occurence of variable $x$ in the subtree of term $M$ that has an underlined node as a root (i.e. subtree $A$). Each recurcive call of \eqref{exp2} substitudes all variables with respect to the corresponding context exactly in one argument term.

Now consider TS for HLR. Note that:
\begin{itemize}
\item Only $[Lam-Elim]$ rule can change an expansion;
\item The number of transitions without applying $[Lam-Elim]$ rule is limited since the definition of context, input term has a final size, and only $[Lam-Elim]$ rule expands the context; Hereafter we will denote a sequence of transitions without applying $[Lam-Elim]$ rule by $\overset{*}{\rightarrow}$;
\item The expansion function $exp$ cannot change a path from the root of term to the underlined node since:
  \begin{itemize}
  \item recurcive call \eqref{exp1} can only change the subtree of the current term with underlined node as a root; \hfill{\textbf{(I)}}
  \item recurcive call \eqref{exp2} can only change arguments of the current term that are above the underlined node; Moreover, each application of \eqref{exp2} change exactly one argument (that corresponds to the first element of the pair in $\Delta$) leaving all other arguments and the subtree of the current term with underlined node as a root intact. \hfill{\textbf{(II)}}
  \end{itemize}
\end{itemize}

\subsubsection{Example}
\begin{align*}
  exp (\textnormal{\eqref{Ex1}})\ & =\  exp (\langle (\lambda \ x\ .\ x)\ \underline{@}\ (\lambda \ y\ .\  y);\ \emptyset;\ [\ ]
  \rangle) =  (\lambda \ x\ .\ x)\ @\ (\lambda \ y\ .\  y) \\
  exp (\textnormal{\eqref{Ex2}})\ & =\ exp ( \langle (\underline{\lambda \ x}\ .\ x)\ @\ (\lambda \ y\ .\  y);\ \emptyset;\
  ((\lambda\ y\ .\ y),\ \emptyset)  \rangle)\ =
  exp ( \langle (\underline{\lambda \ x}\ .\ x)\ @\ (\lambda \ y\ .\  y);\ \emptyset;\
  [\ ]  \rangle)\ \\ & = \ (\lambda \ x\ .\ x)\ @\ (\lambda \ y\ .\  y) \\
  exp (\textnormal{\eqref{Ex3}})\ & =\ exp ( \langle (\xcancel{\lambda \ x}\ .\ \underline{x})\ \xcancel{@}\
  \xcancel{(\lambda \ y\ .\  y)};\ x \mapsto ((\lambda\ y\ .\ y),\ \emptyset);\ [\ ] \rangle ) \\
  & =  exp ( \langle (\xcancel{\lambda \ x}\ .\ \underline{\lambda\ y}\ .\ y)\ \xcancel{@}\
  \xcancel{(\lambda \ y\ .\  y)};\ \emptyset;\ [\ ] \rangle )\ =\ \lambda\ y\ .\ y\\
  exp (\textnormal{\eqref{Ex4}})\ & =\ exp (\langle (\xcancel{\lambda \ x}\ .\ \underline{\lambda \ y}\ . y )\
  \xcancel{@}\ \xcancel{(\lambda \ y\ .\  y)};\ \emptyset; \ [\ ] \rangle)\ =\ \lambda \ y\ .\ y \\
  exp (\textnormal{\eqref{Ex5}})\ & =\ exp (\langle (\xcancel{\lambda \ x}\ .\ \lambda \ y\ . \underline{y} )\
  \xcancel{@}\ \xcancel{(\lambda \ y\ .\  y)};\ \emptyset; \ [\ ] \rangle) \ = \ \lambda \ y\ .\ y
\end{align*}

\paragraph{Correspondence with respect to Head Reduction} (Informally; formally see in the following sections) \\
Expansion cannot be changed by any TS rules except $[Lam-Elim]$ rule. Thus, 
it is easy to see the correspondence between head linear reduction and usual head
reduction. Each application of $[Lam-Elim]$ rule performs exactly one step of head
reduction after applying the $exp$-function.

\begin{align*}
  (\lambda \ x\ .\ x)\ @\ (\lambda \ y\ .\  y) \rightarrow &\ \textnormal{corresponds to first to steps} \\
  \lambda \ y\ .\ y  &\ \textnormal{corresponds to last three steps}
\end{align*}

\subsubsection{Theorem} HLR and HR coincide as follows:

Suppose that we have some current TS state (denoted $\langle \dots \rangle$) with some expansion (denoted $\dots$)
such that the next rule to be applied is $[Lam-Elim]$ and results in state $\langle M_i;\ \Gamma_i;\ \Delta_i \rangle$ witch
expansion is some term $M'_i$. Then TS make several new steps without applying $[Lam-Elim]$ rule and results in some
state $\langle A[\underline{\lambda x}. e];\ \Gamma;\ (B,\Gamma')\bullet\Delta \rangle$ witch expansion is still term
$M'_i$. Then 
\emph{\textbf{If} $[Lam-Elim]$ rule can be applied by extending environment $\Gamma$ with new binding 
  $x \mapsto (B,\Gamma')$ and expansion of the result is some term $M'_{i+1}$
  \textbf{then} $M'_{i+1}$ can be obtained by one step of head reduction from the term $M'_i$}.

\begin{tikzcd}
  \langle \dots \rangle \arrow{rr}{[Lam-Elim]} \arrow{d}{exp} & &
  \langle M_i;\ \Gamma_i;\ \Delta_i \rangle \arrow{d}{exp}
  \arrow{r}{*} & \langle A[\underline{\lambda x}. e];\ \Gamma;\ (B,\Gamma')\bullet\Delta \rangle
  \arrow{dl}{exp}
  \arrow{rr}{[Lam-Elim]} & & \langle A_{\xcancel{B}}[\xcancel{\lambda x}.\underline{e}];\ x \mapsto (B,\Gamma'),\Gamma;\ \Delta \rangle \arrow{d}{exp} &
  \\
  \dots \arrow{rr}{HR} & & M_i' \arrow[dotted]{rrr}{HR} & & & M_{i+1}'
\end{tikzcd}

\paragraph{Proof} by induction on number of $[Lam-Elim]$ steps.

Base: trivial since first element being added to $\Gamma$ is a head redex by definition.

Induction step. We know that after $i^{th}$ application of rule $[Lam-Elim]$ we got some TS state $\langle M_i;\ \Gamma_i;\ \Delta_i \rangle$ which expansion is some term $M_i'$. As was mentioned above $\overset{*}{\rightarrow}$ has not change the expansion and the number of steps in $\overset{*}{\rightarrow}$ is finite. Thus, we have two possible cases:

first, TS got stuck and nothing to prove,

and second, we can apply the $[Lam-Elim]$ rule. In the second case we know the form of the state (following the $[Lam-Elim]$ definition), i.e. $\langle A[\underline{\lambda x}. e];\ \Gamma;\ (B,\Gamma')\bullet\Delta \rangle$ (let us denote it $(i)$), and by assumption the result of applying $[Lam-Elim]$ rule is a state $\langle A_{\xcancel{B}}[\xcancel{\lambda x}.\underline{e}];\ x \mapsto (B,\Gamma'),\Gamma;\ \Delta \rangle$ (let us denote it $(ii)$). Now we have to show that applying function $exp$ to that state results in the same term as a step of head reduction from term $M_i'$. (i.e. in the term $M_{i+1}'$)

Let see what will happend if we apply $exp$ function to state $(i)$:
\begin{align}
  &exp\; \langle A[\underline{\lambda x}.\; e];\ \Gamma;\ (B,\Gamma')\bullet\Delta \rangle & \\
  &\overset{exp}{\rightarrow^{*}}
  exp\; \langle A'[\underline{\lambda x}.\; e[\Gamma]];\ \emptyset;\ (B,\Gamma')\bullet\Delta \rangle &\textnormal{by fully applying \eqref{exp1}} \\
  \label{i3} &\overset{exp}{\rightarrow}
  exp\; \langle A'_{B[\Gamma']}[\underline{\lambda x}.\; e[\Gamma]];\ \emptyset;\ \Delta \rangle &\textnormal{by one step of \eqref{exp2}} \\
  &\overset{exp}{\rightarrow}
  \dots &
\end{align}

to state $(ii)$:
\begin{align}
  &exp \langle A_{\xcancel{B}}[\xcancel{\lambda x}.\; \underline{e}];\ x \mapsto (B,\Gamma'),\Gamma;\ \Delta \rangle & \\
  &\overset{exp}{\rightarrow^{*}}
  exp\;\langle A_{\xcancel{B}}[\xcancel{\lambda x}.\; \underline{e}[\Gamma]];\ x \mapsto (B,\Gamma');\ \Delta \rangle &\textnormal{by elliminating $\Gamma$ following \eqref{exp1}} \\
  \label{ii3} &\overset{exp}{\rightarrow}
  exp\; \langle A_{\xcancel{B}}[\xcancel{\lambda x}.\; \underline{e}[\Gamma][x/B[\Gamma']]];\ \emptyset;\ \Delta \rangle &\textnormal{by one step of \eqref{exp1}} \\
  &\overset{exp}{\rightarrow}
  \dots &
\end{align}

It is easy to see that term in state in \eqref{i3}, $A'_{B[\Gamma']}[\underline{\lambda x}.\; e[\Gamma]]$, has the head redex $(\lambda x,\ B)$ (since context is already empty). Thus, if we apply head reduction to this term, it will results exactly in term $A_{\xcancel{B}}[\xcancel{\lambda x}.\; \underline{e}[\Gamma][x/B[\Gamma']]]$ (by head reduction definition) that is equal to the first component of state \eqref{ii3}. Following \textbf{(I)} and \textbf{(II)}, if we will continue to apply $exp$ function then elliminating the same $\Delta$ in both cases will lead no effect on argument $B$ and underlined subtrees. Thus, $(\lambda x,\ B)$ is a head redex in $M_i'$ and the expansion of state $(ii)$ is $M_{i+1}'$. \hfill{\textbf{Qed}} \\ \\ 

\textbf{Consequences}:
\begin{itemize}
\item if head linear reduction terminates then head reduction terminates;
\item if head reduction terminates then head linear reduction terminates;
\item Since expansion is not able to change a path from the root to the underlined node,
  the first component of the final state of TS for head linear reduction
  contains a term which leftmost path is a part of the head normal form 
  and the expansion of the final state is a node of the Boehm-tree of the input term; \\
  Thus, a repeated application of head linear reduction to all arguments
  (complete head linear reduction) leeds to the normal form.
\end{itemize}


\section{Complete Head Linear Reduction}
\emph{Complete Head Linear Reduction} (CHLR) can be seen as usual head linear reduction that is repeatedly
applied to the all arguments.
In this section transition system for CHLR is presented. It is a simple extension of TS for HLR.

\subsection{Transition System for Complete Head Linear Reduction}

To perform serial application of HLR in all arguments three new rules $[FVar-*]$ are introduced.
Informally, these three rules handle the situation when HLR results is some state with first component
be a term with underlined unbouned (or free) variable.

\begin{itemize}
\item Stack of pairs $\Delta$ is extended by special marker $\$$;
\item \textit{Initial} state is $\langle \lambda-term\ with\ underlined\ root;\ \emptyset;\ \$ \rangle$;
\item \textit{Final} state is $\langle \InContext{M}{\underline{x}} \textnormal{(term in normal form)};\ \Gamma;\ \$ \rangle$;
\item Changes (differences between TS for CHLR and TS for HLR) are {\color{red}colored}
\end{itemize}

$$
\Rule{\State{\InContext{A}{e_1\underline{@}e_2};\;\Gamma;\;\Delta}}
     {\State{\InContext{A}{\underline{e_1}@e_2};\;\Gamma;\;(e_2,\Gamma)\bullet\Delta}}
\RuleNo{App}
$$

$$
\Rule{\State{\InContext{A}{\underline{\lambda x}.e};\;\Gamma;\;{\color{red}\$\bullet\Delta}}}
     {\State{\InContext{A}{\lambda x.\underline{e}};\;\Gamma;\;{\color{red}\$\bullet\Delta}}}
\RuleNo{Lam-Non-Elim}
$$

$$
\Rule{\State{\InContext{A}{\underline{\lambda x}.e};\;\Gamma;\;(B,\Gamma')\bullet\Delta}}
     {\State{\InContext{A_{\xcancel{B}}}{\xcancel{\lambda x}.\underline{e}};\;x \mapsto (B,\Gamma'),\,\Gamma;\;\Delta}}
\RuleNo{Lam-Elim}
$$

$$
\Rule{\State{\InContext{A}{\underline{x}};\;x\mapsto (B,\Gamma'),\,\Gamma;\;\Delta}}
     {\State{\InContext{A}{\underline{B}};\;\Gamma';\;\Delta}}
\RuleNo{BVar}
$$

$$
\Rule{\State{\InContext{A}{\InContext{M}{\underline{x}}@B};\;\Gamma;\;(B,\Gamma')\bullet\$\bullet\Delta}}
     {\State{\InContext{A}{M[x]@\underline{B}};\;\Gamma';\;\$\bullet\Delta}},\;x\notin dom(\Gamma)
\RuleNo{{\color{red}FVar-0}}
$$

$$
\Rule{\State{\InContext{A}{\InContext{M}{\underline{x}}@B};\;\Gamma;\;(B,\Gamma')\bullet C\bullet\Delta}}
     {\State{\InContext{A}{M[x]@\underline{B}};\;\Gamma';\;\$\bullet C\bullet\Delta}},\;C\ne\$,\;x\notin dom(\Gamma)
\RuleNo{{\color{red}FVar-1}}
$$

$$
\Rule{\State{\InContext{A}{\InContext{M}{\underline{x}}@B};\;\Gamma;\;\$\bullet (B,\Gamma')\bullet\Delta}}
     {\State{\InContext{A}{\InContext{M}{x}@\underline{B}};\;\Gamma';\;\Delta_1}},\;\;x\notin dom(\Gamma),\;
     \Delta_1 = \left\{
     \begin{array}{ll}
       \Delta, \textnormal{if } \Delta = \$\bullet \dots \\
         \$\bullet\Delta, \textnormal{otherwise}
       \end{array}
       \right.
\RuleNo{{\color{red}FVar-2}}
$$

\subsection{Expansion function}

Expansion function for TS for CHLR is a simple extansion of the expansion function for TS state for HLR.
Only one new case is added to handle $\$$ appearence on stack : \eqref{exp13}.

\begin{align}
  \label{exp11} exp\; \langle M[\underline{A}];\; \Gamma,\ x \mapsto (B, \Gamma');\; \Delta \rangle
  &= exp\; \langle M[\underline{A}[x / B[\Gamma']]];\; \Gamma;\; \Delta \rangle \\
  \label{exp12} exp\; \langle M_B[\underline{A}];\; \emptyset;\; (B,\Gamma')\bullet\Delta \rangle
  &= exp\; \langle M_{B[\Gamma']}[\underline{A}];\; \emptyset;\; \Delta \rangle\\
  \label{exp13}  {\color{red} exp\; \langle M_B[\underline{A}];\; \emptyset;\;  \$ \bullet \Delta \rangle}
  &{\color{red}= exp\; \langle M_{B[\Gamma']}[\underline{A}];\; \emptyset;\; \Delta \rangle } \\
  \label{exp14} exp\; \langle M;\; \emptyset;\; [\ ] \rangle &= M' \\
  \textnormal{where } B[\Gamma'] &= exp\; \langle \underline{B};\; \Gamma';\; [\ ] \rangle \\
  & M' \textnormal{ is a term } M \textnormal{ where all nodes that are crossed over are crosed out }
\end{align}


\subsection{Example}
$$((\lambda h\ \lambda z\ .\ (h\ @_1\ (\lambda x\ .\ ((h\ @_2\ (\lambda q\ .\ x))\ @_3\ a)))\ @_4\ (z\ @_5\ a))\
@_6\ (\lambda f\ \lambda y\ .\ f\ @_7\ ((g\ @_8\ (\lambda h\ .\ h))\ @_9\ y)))\ @_{10}\ (g\ @_{11}\ (\lambda n\ .\ n))
$$

\begin{tikzpicture}[sibling distance=3em,level distance=2em]
  \node {$@_{10}$}[sibling distance=10em]
  child { node {$@_{6}$}
    child { node {$\lambda h$}[sibling distance=6em]
      child { node {$\lambda z$}
        child { node {$@_4$}
          child { node {$@_1$}[sibling distance=3em]
            child { node {$h$}}
            child { node {$\lambda x$}
              child { node {$@_3$}
                child { node {$@_2$}
                  child { node {$h$}}
                  child { node {$\lambda q$}
                    child { node {$x$}}
                  }
                }
                child { node {$a$}}
              }
            }
          }
          child { node {$@_5$}[sibling distance=3em] 
            child { node {$z$}}
            child { node {$a$}}
          }
        }
      }
    }
    child { node {$\lambda f$}[sibling distance=3em]
      child { node {$\lambda y$}
        child { node {$@_{7}$}
          child { node {$f$}}
          child { node {$@_{9}$}
            child { node {$@_{8}$}
              child { node {$g$}}
              child { node {$\lambda b$}
                child { node {$b$}}
              }
            }
            child { node {$y$}}
          }
        }
      }
    }
  }
  child { node {$@_{11}$}[sibling distance=3em]
    child { node {$g$}}
    child { node {$\lambda n$}
      child { node {$n$}}}}
  ;
\end{tikzpicture}

\begin{align*}
  \langle \begin{tikzpicture}[sibling distance=2em,level distance=2em]
    \node {\underline{$@_{10}$}}
    child { node {$@_6$}
      child { node {$\dots$}}}
    child { node {$@_{11}$}
      child { node {$\dots$}}};
  \end{tikzpicture};\ \emptyset;\ \$ \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=2em,level distance=2em]
    \node {$@_{10}$}
    child { node {\underline{$@_6$}}
      child { node {$\dots$}}}
    child { node {$@_{11}$}
      child { node {$\dots$}}};
  \end{tikzpicture};\ \emptyset;\ (@_{11}, \emptyset) \bullet \$ \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=2em,level distance=2em]
    \node {$@_{10}$}
    child { node {$@_6$}
      child { node {\underline{$\lambda h$}}
        child { node {$\dots$}}}}
    child { node {$@_{11}$}
      child { node {$\dots$}}};
  \end{tikzpicture};\ \emptyset;\ (\lambda f, \emptyset) \bullet (@_{11}, \emptyset) \bullet \$
  \rangle & \rightarrow^{[Lam-Elim]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {$@_{10}$}
    child { node {\xcancel{$@_6$}}
      child { node {\xcancel{$\lambda h$}}
        child { node {\underline{$\lambda z$}}
          child { node {$\dots$}}}}
      child { node {\xcancel{$\lambda f$}}
        child { node {\xcancel{$\dots$}}}}}
    child { node {$@_{11}$}
      child { node {$\dots$}}};
  \end{tikzpicture};\ \{h \mapsto (\lambda f, \emptyset)\};\
  (@_{11}, \emptyset) \bullet \$  \rangle & \rightarrow^{[Lam-Elim]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$@_{10}$}}
    child { node {\xcancel{$@_6$}}
      child { node {\xcancel{$\lambda h$}}
        child { node {\xcancel{$\lambda z$}}
          child { node {\underline{$@_4$}}
            child { node {$\dots$}}
            child { node {$\dots$}}}}}
      child { node {\xcancel{$\lambda f$}}
        child { node {\xcancel{$\dots$}}}}}
    child { node {\xcancel{$@_{11}$}}
      child { node {\xcancel{$\dots$}}}};
  \end{tikzpicture};\ \underbrace{\{z \mapsto (@_{11},\ \emptyset),\
    h \mapsto (\lambda f, \emptyset)\}}_{\Gamma_1};\ \$  \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_4$}
      child { node {\underline{$@_1$}}
        child { node {$h$}}
        child { node {$\dots$}}}
      child { node {$\dots$}}};
  \end{tikzpicture};\ \Gamma_1;\ (@_5,\ \Gamma_1) \bullet \$  \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_4$}
      child { node {$@_1$}
        child { node {\underline{$h$}}}
        child { node {$\dots$}}}
      child { node {$\dots$}}};
  \end{tikzpicture};\ \Gamma_1;\ (\lambda x,\ \Gamma_1) \bullet (@_5,\ \Gamma_1) \bullet \$  \rangle & \rightarrow^{[BVar]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_4$}
      child { node {$@_1$}
        child { node {\underline{$\lambda f$}}
          child { node {$\lambda y$}
            child { node {$\dots$}}}}
        child { node {$\dots$}}}
      child { node {$\dots$}}};
  \end{tikzpicture};\ \emptyset;\ (\lambda x,\ \Gamma_1) \bullet (@_5,\ \Gamma_1) \bullet \$  \rangle &
  \rightarrow^{[Lam-Elim]}\\
  \hline
\end{align*}
\begin{align*}
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_4$}
      child { node {\xcancel{$@_1$}}
        child { node {\xcancel{$\lambda f$}}
          child { node {\underline{$\lambda y$}}
            child { node {$\dots$}}}}
        child { node {\xcancel{$\dots$}}}}
      child { node {$\dots$}}};
  \end{tikzpicture};\ \{f \mapsto (\lambda x,\ \Gamma_1)\};\ (@_5,\ \Gamma_1) \bullet \$  \rangle &
  \rightarrow^{[Lam-Elim]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {\xcancel{$@_4$}}
      child { node {\xcancel{$@_1$}}
        child { node {\xcancel{$\lambda f$}}
          child { node {\xcancel{$\lambda y$}}
            child { node {\underline{$@_7$}}
              child { node {$f$}}
              child { node {$\cdots$}}}}}
        child { node {\xcancel{$\dots$}}}}
      child { node {\xcancel{$\dots$}}}};
  \end{tikzpicture};\ \underbrace{\{y \mapsto (@_5,\ \Gamma_1),\ f \mapsto (\lambda x,\ \Gamma_1)\}}_{\Gamma_2}
  ;\ \$  \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_7$}
      child { node {$\underline{f}$}}
      child { node {$\cdots$}}};
  \end{tikzpicture};\ \Gamma_2;\ (@_9,\ \Gamma_2) \bullet\$  \rangle & \rightarrow^{[BVar]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_7$}
      child { node {$\underline{\lambda q}$}
        child { node {$@_3$}
          child { node {$@_2$}
            child { node {$\dots$}}
            child { node {$\dots$}}}
          child { node {$\dots$}}}}
      child { node {$\cdots$}}};
  \end{tikzpicture};\ \Gamma_1;\ (@_9,\ \Gamma_2) \bullet\$  \rangle & \rightarrow^{[Lam-Elim]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$\xcancel{@_7}$}
      child { node {$\xcancel{\lambda x}$}
        child { node {$\underline{@_3}$}
          child { node {$@_2$}
            child { node {$h$}}
            child { node {$\lambda q \; \dots$}}}
          child { node {$a$}}}}
      child { node {\xcancel{$\cdots$}}}};
  \end{tikzpicture};\
  \underbrace{\{x \mapsto (@_9,\ \Gamma_2)\} \cup \Gamma_1}_{\Gamma_3};\ \$  \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_3$}
      child { node {\underline{$@_2$}}
        child { node {$h$}}
        child { node {$\lambda q \; \dots$}}}
      child { node {$a$}}};
  \end{tikzpicture};\ \Gamma_3;\ (a,\ \Gamma_3) \bullet\$  \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_3$}
      child { node {$@_2$}
        child { node {\underline{$h$}}}
        child { node {$\lambda q \; \dots$}}}
      child { node {$a$}}};
  \end{tikzpicture};\ \Gamma_3;\ (\lambda q,\ \Gamma_3) \bullet (a,\ \Gamma_3) \bullet\$  \rangle & \rightarrow^{[BVar]} \\
  \hline
\end{align*}
\begin{align*}
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_3$}
      child { node {$@_2$}
        child { node {\underline{$\lambda f$}}
          child { node {$\lambda y$}
            child { node {$\dots$}}}}
        child { node {$\lambda q \; \dots$}}}
      child { node {$a$}}};
  \end{tikzpicture};\ \emptyset;\ (\lambda q,\ \Gamma_3) \bullet (a,\ \Gamma_3) \bullet\$  \rangle & \rightarrow^{[Lam-Elim]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_3$}
      child { node {\xcancel{$@_2$}}
        child { node {\xcancel{$\lambda f$}}
          child { node {\underline{$\lambda y$}}
            child { node {$\dots$}}}}
        child { node {\xcancel{$\lambda q \; \dots$}}}}
      child { node {$a$}}};
  \end{tikzpicture};\ \{f \mapsto (\lambda q,\ \Gamma_3)\};\ (a,\ \Gamma_3) \bullet\$  \rangle & \rightarrow^{[Lam-Elim]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {\xcancel{$@_3$}}
      child { node {\xcancel{$@_2$}}
        child { node {\xcancel{$\lambda f$}}
          child { node {\xcancel{$\lambda y$}}
            child { node {\underline{$@_7$}}
              child { node {$f$}}
              child { node {$@_9\;\dots$}}}}}
        child { node {\xcancel{$\lambda q \; \dots$}}}}
      child { node {\xcancel{$a$}}}};
  \end{tikzpicture};\ \underbrace{\{y \mapsto (a,\ \Gamma_3),\ f \mapsto (\lambda q,\ \Gamma_3)\}}_{\Gamma_4};\
  \$  \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_7$}
      child { node {\underline{$f$}}}
      child { node {$@_9\;\dots$}}};
  \end{tikzpicture};\ \Gamma_4;\ (@_9,\ \Gamma_4) \bullet \$ \rangle & \rightarrow^{[BVar]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_7$}
      child { node {\underline{$\lambda q$}}
        child { node {$x$}}}
      child { node {$@_9\;\dots$}}};
  \end{tikzpicture};\ \Gamma_3;\ (@_9,\ \Gamma_4) \bullet \$ \rangle & \rightarrow^{[Lam-Elim]}\\
  \hline
%%\end{align*}
%%\newpage
%% \begin{align*}
%% \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
%%     \node {\xcancel{$\dots$}}
%%     child { node {\xcancel{$@_7$}}
%%       child { node {\xcancel{$\lambda x$}}
%%         child { node {$\underline{@_3}$}
%%           child { node {$\dots$}}
%%           child { node {$\dots$}}}}
%%       child { node {\xcancel{$@_9\;\dots$}}}};
%% \end{tikzpicture};\ \underbrace{\{x \mapsto (@_9,\ \Gamma_4)\} \cup \Gamma_3}_{\Gamma_5};\
%% \$ \rangle & \rightarrow^{[App]}\\
%% \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
%%     \node {\xcancel{$\dots$}}
%%     child { node {$@_3$}
%%       child { node {$\underline{@_2}$}
%%         child { node {$h$}}
%%         child { node {$\lambda q\; \dots$}}}
%%       child { node {$a$}}};
%% \end{tikzpicture};\ \Gamma_5;\ (a,\ \Gamma_5) \bullet \$ \rangle & \rightarrow^{[App]} \\
%% \hline
%% \end{align*}
%%\begin{align*}
%% \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
%%     \node {\xcancel{$\dots$}}
%%     child { node {$@_3$}
%%       child { node {$@_2$}
%%         child { node {\underline{$h$}}}
%%         child { node {$\lambda q\; \dots$}}}
%%       child { node {$a$}}};
%% \end{tikzpicture};\ \Gamma_5;\ (\lambda q,\ \Gamma_5) \bullet (a,\ \Gamma_5) \bullet \$ \rangle & \rightarrow^{[App]}\\
%% \hline
%% \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
%%     \node {\xcancel{$\dots$}}
%%     child { node {$@_3$}
%%       child { node {$@_2$}
%%         child { node {\underline{$\lambda f$}}
%%           child { node {$\lambda y$}
%%             child { node {$\dots$}}}}
%%         child { node {$\lambda q\; \dots$}}}
%%       child { node {$a$}}};
%% \end{tikzpicture};\ \Gamma_5;\ (\lambda q,\ \Gamma_5) \bullet (a,\ \Gamma_5) \bullet \$ \rangle & \rightarrow^{[Lam-Elim]}\\
%% \hline
%% \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
%%     \node {\xcancel{$\dots$}}
%%     child { node {$@_3$}
%%       child { node {\xcancel{$@_2$}}
%%         child { node {\xcancel{$\lambda f$}}
%%           child { node {\underline{$\lambda y$}}
%%             child { node {$\dots$}}}}
%%         child { node {\xcancel{$\lambda q\; \dots$}}}}
%%       child { node {$a$}}};
%% \end{tikzpicture};\ \{f \mapsto (\lambda q,\ \Gamma_5)\} \cup \Gamma_5;\ (a,\ \Gamma_5) \bullet \$ \rangle
%% & \rightarrow^{[Lam-Elim]}\\
%% \hline
%% \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
%%     \node {\xcancel{$\dots$}}
%%     child { node {\xcancel{$@_3$}}
%%       child { node {\xcancel{$@_2$}}
%%         child { node {\xcancel{$\lambda f$}}
%%           child { node {\xcancel{$\lambda y$}}
%%             child { node {\underline{$@_7$}}}}}
%%         child { node {\xcancel{$\lambda q\; \dots$}}}}
%%       child { node {\xcancel{$a$}}}};
%% \end{tikzpicture};\ \underbrace{\{y \mapsto (a,\ \Gamma_5),\ f \mapsto (\lambda q,\ \Gamma_5)\} \cup \Gamma_5}_{\Gamma_6};\ \$ \rangle
%% & \rightarrow^{[App]}\\
%% \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
%%     \node {\xcancel{$\dots$}}
%%     child { node {$@_7$}
%%       child { node {$\underline{f}$}}
%%       child { node {$@_9 \dots$}}};
%% \end{tikzpicture};\ \Gamma_6;\ (@_9,\ \Gamma_6) \bullet \$ \rangle
%% & \rightarrow^{[BVar]}\\
%% \hline
%% \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
%%     \node {\xcancel{$\dots$}}
%%     child { node {$@_7$}
%%       child { node {$\underline{\lambda q}$}
%%         child { node {$x$}}}
%%       child { node {$@_9 \dots$}}};
%% \end{tikzpicture};\ \underbrace{\{q \mapsto (@_9,\ \Gamma_3)\} \cup \Gamma_3}_{\Gamma_5};\
%% (@_9,\ \Gamma_6) \bullet \$ \rangle
%% & \rightarrow^{[Lam-Elim]}\\
%%\hline
\langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$\xcancel{@_7}$}
      child { node {$\xcancel{\lambda q}$}
        child { node {$\underline{x}$}}}
      child { node {$\xcancel{@_9 \dots}$}}};
\end{tikzpicture};\ \{q \mapsto (@_9,\ \Gamma_3)\} \cup \Gamma_3;\ \$ \rangle
& \rightarrow^{[BVar]}\\
\hline
\langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$\underline{@_9}$}
      child { node {$@_8\ \dots$}}
      child { node {$y$}}};
\end{tikzpicture};\ \{q \mapsto (@_9,\ \Gamma_3)\} \cup \Gamma_3;\ \$ \rangle
& \rightarrow^{[App]} \\
\hline
\end{align*}
\begin{align*}
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$\underline{@_8}$}
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$y$}}};
  \end{tikzpicture};\ \Gamma_2;\ (y,\ \Gamma_2) \bullet \$ \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}
        child { node {$\underline{g}$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$y$}}};
  \end{tikzpicture};\ \Gamma_2;\ (\lambda b,\ \Gamma_2) \bullet (y,\ \Gamma_2) \bullet \$ \rangle &
  \rightarrow^{\color{red}[FVar-1]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}
        child { node {$g$}}
        child { node {$\underline{\lambda b}$}
          child { node {$b$}}}}
      child { node {$y$}}};
  \end{tikzpicture};\ \Gamma_2;\ \$ \bullet (y,\ \Gamma_2) \bullet \$ \rangle & \rightarrow^{[Lam-Non-Elim]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$\underline{b}$}}}}
      child { node {$y$}}};
  \end{tikzpicture};\ \Gamma_2;\ \$ \bullet (y,\ \Gamma_2) \bullet \$ \rangle & \rightarrow^{[FVar-?]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$\underline{y}$}}};
  \end{tikzpicture};\ \Gamma_2;\ \$ \rangle & \rightarrow^{[BVar]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=3em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}[sibling distance=1em]
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$\underline{@_5}$}[sibling distance=1em]
        child { node {$z$}}
        child { node {$a$}}}};
  \end{tikzpicture};\ \Gamma_1;\ \$ \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=5em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}[sibling distance=1em]
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$@_5$}[sibling distance=3em]
        child { node {$\underline{z}$}}
        child { node {$a$}}}};
  \end{tikzpicture};\ \Gamma_1;\ (a,\ \Gamma_1) \bullet \$ \rangle & \rightarrow^{[BVar]} \\
  \hline
\end{align*}
\begin{align*}
  \langle \begin{tikzpicture}[sibling distance=5em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}[sibling distance=1em]
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$@_5$}[sibling distance=3em]
        child { node {$\underline{@_{11}}$}
          child { node {$g$}}
          child { node {$\lambda n$}
            child { node {$n$}}}}
        child { node {$a$}}}};
  \end{tikzpicture};\ \emptyset;\ (a,\ \Gamma_1) \bullet \$ \rangle & \rightarrow^{[App]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=5em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}[sibling distance=1em]
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$@_5$}[sibling distance=3em]
        child { node {$@_{11}$}
          child { node {$\underline{g}$}}
          child { node {$\lambda n$}
            child { node {$n$}}}}
        child { node {$a$}}}};
  \end{tikzpicture};\ \emptyset;\ (\lambda n,\ \emptyset) \bullet (a,\ \Gamma_1) \bullet \$ \rangle &
  \rightarrow^{\color{red}[FVar-1]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=5em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}[sibling distance=1em]
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$@_5$}[sibling distance=3em]
        child { node {$@_{11}$}
          child { node {$g$}}
          child { node {$\underline{\lambda n}$}
            child { node {$n$}}}}
        child { node {$a$}}}};
  \end{tikzpicture};\ \emptyset;\ \$ \bullet (a,\ \Gamma_1) \bullet \$ \rangle & \rightarrow^{[Lam-Non-Elim]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=5em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}[sibling distance=1em]
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$@_5$}[sibling distance=3em]
        child { node {$@_{11}$}
          child { node {$g$}}
          child { node {$\lambda n$}
            child { node {$\underline{n}$}}}}
        child { node {$a$}}}};
  \end{tikzpicture};\ \emptyset;\ \$ \bullet (a,\ \Gamma_1) \bullet \$ \rangle & \rightarrow^{\color{red}[FVar-2]}\\
  \hline
  \langle \begin{tikzpicture}[sibling distance=5em,level distance=2em]
    \node {\xcancel{$\dots$}}
    child { node {$@_9$}
      child { node {$@_8$}[sibling distance=1em]
        child { node {$g$}}
        child { node {$\lambda b$}
          child { node {$b$}}}}
      child { node {$@_5$}[sibling distance=3em]
        child { node {$@_{11}$}
          child { node {$g$}}
          child { node {$\lambda n$}
            child { node {$n$}}}}
        child { node {$\underline{a}$}}}};
  \end{tikzpicture};\ \Gamma_1;\ \$ \rangle & \not\rightarrow
\end{align*}


\section{Transition System for UNP}
This section contains TS for UNP. This TS has the same number of rules that the TS for CHLR.
Moreover, it is easy to see that rules with the same name corresponds to each other. \\ \\

There are two pointer types:
\begin{itemize}
\item Binder pointer (denoted as {\color{green}$\rightarrow$});
  from the bound variables binder pointer points to the dynamic binder in the history
  and for all other nodes it points points to the parent;
  (these kind of pointer is omitted in these notes since they can
  be easly defined by recurcive procedure)
\item Pointer to the last incomplete application; there are two subtypes
  of this pointer:
  \begin{itemize}
  \item Thick brown pointer can binds either
    lambda node and application (in this case they arrise as \emph{spine redexes})
    or any other node and some application;
  \item Vioilet pointer has the same meaning
    (pointer to the last incamplete application) together with $\$$
    in TS for CHLR;
  \item Dashed red pointer is used when the real colour
    (brown or violet) is not the metter.    
  \end{itemize}
\end{itemize}

Rules to construct a traversal:
\begin{itemize}
\item $(BVar)$
  \[\tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{2}{$@$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{3}{$\lambda x$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{4}{$x$}
  \ \ \tikzmark{}{$\longrightarrow$ where $e$ is is a right child of $@$ $\longrightarrow$}
  \ \ \tikzmark{11}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{12}{$@$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{13}{$\lambda x$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{14}{$x$}\ \ \tikzmark{15}{$=$}\ \ \tikzmark{16}{$e$}\]
  \begin{tikzpicture}[remember picture,overlay]
    {\color{brown}\draw[solid,line width=1mm,->] (3.north) to[bend right] (2.north);}
    {\color{green}\draw[->] (4.south) to[bend left] (3.south);}
    {\color{red}\draw[line width=0.5mm,dashed,<-]   ($(4.north)+(0,0.5)$)
      node[above,align=left,black] {$i$}  -- (4);}
    {\color{brown}\draw[solid,line width=1mm,->] (13.north) to[bend right] (12.north);}
    {\color{green}\draw[->] (14.south) to[bend left] (13.south);}
    {\color{red}\draw[line width=0.5mm,dashed,<-]   ($(14.north)+(0,0.5)$)
      node[above,align=left,black] {$i$}  -- (14);}
    {\color{red}\draw[line width=0.5mm,dashed,<-]   ($(14.north)+(0.1,0.5)$)
      node[above,align=left,black] {$$}  -- (16);}
  \end{tikzpicture}
  \\ \\ NB: the colour of the added (red) pointer has to be the same as the colour of the first "red" pointer \\ \\
\item $(Lam-Non-Elim)$
  \[\tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{2}{$@$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{3}{$\lambda x$}
  \ \ \tikzmark{}{$\longrightarrow$ where $e$ is a right child of $@$ $\longrightarrow$}
  \ \ \tikzmark{11}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{12}{$@$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{13}{$\lambda x$}\ \ \tikzmark{14}{$e$}\]
  \begin{tikzpicture}[remember picture,overlay]
    {\color{violet}\draw[line width=0.5mm,|->] (3.north) to[bend right] (2.north);}
    {\color{violet}\draw[line width=0.5mm,|->] (13.north) to[bend right] (12.north);}
    {\color{violet}\draw[line width=0.5mm,|->] (14.north) to[bend right] (12.north);}
  \end{tikzpicture}
  \\ \\
\item $(Lam-Elim)$
  \[\tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{2}{$@_1$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{3}{$@_2$}
  \ \ \tikzmark{}{$\dots$}\ \ \tikzmark{4}{$\lambda x$}
  \ \ \tikzmark{}{$\longrightarrow$ where $e$ is a child of $\lambda x$ $\longrightarrow$}
  \ \ \tikzmark{11}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{12}{$@_1$}\ \ \tikzmark{}{$\dots$}
  \ \ \tikzmark{13}{$@_2$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{14}{$\lambda x$}\ \ \tikzmark{15}{$e$}\]
  \begin{tikzpicture}[remember picture,overlay]
    {\color{red}\draw[line width=0.5mm,dashed,->] (3.north) to[bend right] (2.north);}
    {\color{brown}\draw[solid,line width=1mm,->] (4.north) to[bend right] (3.north);}
    {\color{red}\draw[line width=0.5mm,dashed,->] (13.north) to[bend right] (12.north);}
    {\color{brown}\draw[solid,line width=1mm,->] (14.north) to[bend right] (13.north);}
    {\color{red}\draw[line width=0.5mm,dashed,->] (15.north) to[bend right] (12.north);}
  \end{tikzpicture}
  \\ \\ NB: the colour of the added (red) pointer has to be the same as the colour of the first "red" pointer \\ \\
\item $(App)$
  \[\tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{2}{$@$}
  \ \ \tikzmark{}{$\longrightarrow$ where $e$ is a left child of $@$ $\longrightarrow$}
  \ \ \tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{12}{$@$}\ \ \tikzmark{13}{$e$}\]
  \begin{tikzpicture}[remember picture,overlay]
    {\color{brown}\draw[solid,line width=1mm,->] (13.north) to[bend right] (12.north);}
  \end{tikzpicture}
\item $(FVar-0)$
  \[\tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{2}{$@_1$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{3}{$@_2$}
  \ \ \tikzmark{}{$\dots$}\ \ \tikzmark{4}{$y$}
  \ \ \tikzmark{}{$\longrightarrow$ where $e$ is a right child of $@_2$ $\longrightarrow$}
  \ \ \tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{12}{$@_1$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{13}{$@_2$}
  \ \ \tikzmark{}{$\dots$}\ \ \tikzmark{14}{$y$}\ \ \tikzmark{}{$||$}\ \ \tikzmark{15}{$e$}\]
  \begin{tikzpicture}[remember picture,overlay]
    {\color{violet}\draw[line width=0.5mm,|->] (3.north) to[bend right] (2.north);}
    {\color{brown}\draw[solid,line width=1mm,->] (4.north) to[bend right] (3.north);}
    {\color{violet}\draw[line width=0.5mm,|->] (13.north) to[bend right] (12.north);}
    {\color{brown}\draw[solid,line width=1mm,->] (14.north) to[bend right] (13.north);}
    {\color{violet}\draw[line width=0.5mm,|->] (15.north) to[bend right] (12.north);}
  \end{tikzpicture}
\item $(FVar-1)$
  \[\tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{2}{$@_1$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{3}{$@_2$}
  \ \ \tikzmark{}{$\dots$}\ \ \tikzmark{4}{$y$}
  \ \ \tikzmark{}{$\longrightarrow$ where $e$ is a right child of $@_2$ $\longrightarrow$}
  \ \ \tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{12}{$@_1$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{13}{$@_2$}
  \ \ \tikzmark{}{$\dots$}\ \ \tikzmark{14}{$y$}\ \ \tikzmark{}{$||$}\ \ \tikzmark{15}{$e$}\]
  \begin{tikzpicture}[remember picture,overlay]
    {\color{brown}\draw[dashed,line width=1mm,->] (3.north) to[bend right] (2.north);}
    {\color{brown}\draw[solid,line width=1mm,->] (4.north) to[bend right] (3.north);}
    {\color{brown}\draw[dashed,line width=1mm,->] (13.north) to[bend right] (12.north);}
    {\color{brown}\draw[solid,line width=1mm,->] (14.north) to[bend right] (13.north);}
    {\color{violet}\draw[line width=0.5mm,|->] (15.north) to[bend right] (12.north);}
  \end{tikzpicture}
\item $(FVar-2)$
  \[\tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{2}{$@_1$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{3}{$@_2$}
  \ \ \tikzmark{}{$\dots$}\ \ \tikzmark{4}{$y$}
  \ \ \tikzmark{}{$\longrightarrow$ where $e$ is a right child of $@_2$ $\longrightarrow$}
  \ \ \tikzmark{1}{}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{12}{$@_1$}\ \ \tikzmark{}{$\dots$}\ \ \tikzmark{13}{$@_2$}
  \ \ \tikzmark{}{$\dots$}\ \ \tikzmark{14}{$y$}\ \ \tikzmark{}{$||$}\ \ \tikzmark{15}{$e$}\]
  \begin{tikzpicture}[remember picture,overlay]
    {\color{red}\draw[line width=0.5mm,dashed,->] (3.north) to[bend right] (2.north);}
    {\color{violet}\draw[line width=0.5mm,|->] (4.north) to[bend right] (3.north);}
    {\color{red}\draw[line width=0.5mm,dashed,->] (13.north) to[bend right] (12.north);}
    {\color{violet}\draw[line width=0.5mm,|->] (14.north) to[bend right] (13.north);}
    {\color{violet}\draw[line width=0.5mm,|->] (15.north) to[bend right] (12.north);}
  \end{tikzpicture}
  \\ \\ NB: the colour of the "red" pointer is not the metter in this case \\ \\
\end{itemize}

Note that $\Delta$ and $\Gamma$ can be easly defined from UNP TS state as follows:
\begin{itemize}
\item $\Delta$ can be construct by following incomplete application pointer and storing right childs of all reachable applications in reverse order with corresponding contexts (see next item how to define context from traversal);
\item $\Gamma$ can be construct by following binder pointers, and when faces with a lambda--tokens $\lambda x$ which has a brown pointer to some application $@$, store $x \mapsto (e, \Gamma')$ where $e$ is a right child of apllication $@$ and $\Gamma'$ is a context (which is defined recursively from token $@$).
\end{itemize}






%% \subsection{Correctness proof}

%% \subsubsection{Residual term $\InContext{M}{\underline{x}}$ has no redexes}
%% \paragraph{Proof}
%% We will prove by induction (with step size equal to 2) on number of steps that there is no way for redexes to appear in a path from the root to the current underlined node:
%% \begin{itemize}
%% \item \textbf{Base} $\;$ Straightforward:
%%   \begin{enumerate}
%%   \item $n == 0$, empty term has no redexes;
%%   \item $n == 1$, path from root to itself contains no redexes.
%%   \end{enumerate}
%% \item \textbf{Induction Hypothesis} There is no redexes for all paths with a length less than $n$ ($2 \leq n$).
%% \item \textbf{Induction Step ()}\\
%%   Redex is an \textit{application node with $\lambda$-expression as a left child}. We will show that there is no way to construct such subtree without crossing application node out by case analisys on a current (the underlined one) node form:
%%   \begin{itemize}
%%   \item For $[Lam-*],\ [BVar],\ [FVar-*]$ rules this is obvious: they do not add $\lambda$ as a left or down child of some node.
%%   \item The only interesting case is $[App]$ rule. I.e. the rule that was applied on previous step is an $[App]$-rule.
%%     Here we have two possibilities:
%%     \begin{itemize}
%%     \item $e_1 \ne \lambda\ x$; in this case no redexes appear.
%%     \item $e_1 == \lambda\ x$, for some $x$. In this case a redex appears but by $[App]$-rule we have:\\
%%       $\Rule{\State{\InContext{A}{e_1\underline{@}e_2};\;\Gamma;\;\Delta}}
%%        {\State{\InContext{A}{\underline{e_1}@e_2};\;\Gamma;\;e_2\bullet\Delta}}$.\\
%%       Note, that there \textit{exists} a rule that can be applied next --- $[Lam-Elim]$, and no other rule can be applied. This rule will cross application node with its right subterm out.\\
%%     \end{itemize}
%%   \end{itemize}
%%   Thus, no new redexes can appear.
%% \end{itemize}

%% \subsubsection{Only $\langle \InContext{M}{\underline{x}},\ \Gamma,\ \$ \rangle$ can be a final state}
%% \paragraph{Proof}
%% \begin{itemize}
%% \item It is easy to see that the state $\langle \InContext{M}{\underline{x}},\ \Gamma,\ \$ \rangle$ is a final state: there is no rules that can be applied.
%% \item Let's prove that there is no other final states (with respect to the form of the state). Consider another state which either :
%%   \begin{itemize}
%%   \item If current term is not equal to $\InContext{M}{\underline{x}}$ then either $[App]$ or $[Lam-*]$ can be applied.
%%   (together they have no restrictions on $\Gamma$ and $\Delta$)
%%   \item If $\Delta \ne \$$. Note that $\Delta$ can not be empty because there is no rule that can move $\$$ that is on the bottom of it. Thus, $\Delta = A \dots \$$ where either $A == \$$ or $A \ne \$$. In this case one of $[FVar-*]$ rules can be applied.
%%   \end{itemize}
%% \end{itemize}


%% \section{Small-step semantics for Head Linear Reduction}

%% In this section small-step semantics for head linear reduction is presented.
%% Note that this is not complete HLR.
%% I.e. it has to leed to \underline{head normal form}.

%% \paragraph{Axioms}
%% \begin{align*}
%%   \Theta,\ (\lambda x . s) t\ &\overset{e}{\rightarrow} \Theta(\overset{x}{t}),\ s & [Expansion]\\
%%   \Theta,\ x\ &\overset{r}{\rightarrow} \Theta,\ fresh(\Theta(x)),\; if\ \Theta(x) \downarrow & [Read]
%% \end{align*}

%% \paragraph{Rules}
%% $$ \frac{\Theta.\ s\ \rightarrow \ \Theta^{'}.\ s^{'}}
%% {\Theta,\ st \rightarrow\ \Theta^{'},\ s^{'}t}
%% \hfill [App]$$
%% $$ \frac{\Theta.\ s\ \rightarrow \ \Theta^{'}.\ s^{'} \;\;\; x \not\in N(\Theta)}
%% {\Theta,\ \lambda x.s \rightarrow\ \Theta^{'},\ \lambda x. s^{'}}
%% \hfill [Lam]
%% $$
                 
%% \paragraph{Theorem.}








\end{document}

%% Comutting diagrams
%% \begin{tikzcd}
%% T
%% \arrow[drr, bend left, "x"]
%% \arrow[ddr, bend right, "y"]
%% \arrow[dr, dotted, "{(x,y)}" description] & & \\
%% & X \times_Z Y \arrow[r, "p"] \arrow[d, "q"]
%% & X \arrow[d, "f"] \\
%% & Y \arrow[r, "g"]
%% & Z
%% \end{tikzcd}
