#lang racket
(define (CGOTO t i) (let ((q (- (cadar t) 1))) (CGOTO1 (caar (pfx q t)) t q i)))
(define (CGOTO1 have t p i)
  (if (not (member have '(P X AD AH)))
      (if (equal? have 'B)
          (if (equal? i 4)
              (AG (cons (list 'AG p) t))
              (if (equal? i 3)
                  (AC (cons (list 'AC p) t))
                  (if (equal? i 2)
                      (W (cons (list 'W p) t))
                      (if (equal? i 1) (O (cons (list 'O p) t)) (error 'GOTO:ERROR)))))
          (if (equal? have 'D)
              (if (equal? i 2)
                  (M (cons (list 'M p) t))
                  (if (equal? i 1) (E (cons (list 'E p) t)) (error 'GOTO:ERROR)))
              (if (equal? have 'F)
                  (if (equal? i 2)
                      (K (cons (list 'K p) t))
                      (if (equal? i 1) (G (cons (list 'G p) t)) (error 'GOTO:ERROR)))
                  (if (equal? have 'H)
                      (if (equal? i 1) (I (cons (list 'I p) t)) (error 'GOTO:ERROR))
                      (if (equal? have 'P)
                          (if (equal? i 2)
                              (U (cons (list 'U p) t))
                              (if (equal? i 1) (Q (cons (list 'Q p) t)) (error 'GOTO:ERROR)))
                          (if (equal? have 'R)
                              (if (equal? i 1) (S (cons (list 'S p) t)) (error 'GOTO:ERROR))
                              (if (equal? have 'X)
                                  (if (equal? i 2)
                                      (AA1 (cons (list 'AA1 p) t))
                                      (if (equal? i 1) (Y (cons (list 'Y p) t)) (error 'GOTO:ERROR)))
                                  (if (equal? have 'Z)
                                      (if (equal? i 1) (AA (cons (list 'AA p) t)) (error 'GOTO:ERROR))
                                      (if (equal? have 'AD)
                                          (if (equal? i 1) (AE (cons (list 'AE p) t)) (error 'GOTO:ERROR))
                                          (error 'ERROR))))))))))
      (cons `EOT t)))
(define (FQ have t)
  (letrec ((f
            (lambda (t0)
              (if (equal? have (caar t0))
                  (length t0)
                  (let ((bp (cadar t0))) (f (pfx (- bp 1) t)))))))
    (f t)))
(define (pfx n t) (reverse (take n (reverse t))))
(define (take n xs) (if (equal? n 0) '() (cons (car xs) (take (- n 1) (cdr xs)))))
(define (travout t) (if (null? t) '() (begin (travout (cdr t)) (newline) (write (car t)))))
(define (A t) (B (cons (list 'B 0) t)))
(define (B t) (C (cons (list 'C (length t)) t)))
(define (C t) (D (cons (list 'D (FQ 'C t)) t)))
(define (D t) (CGOTO t 1))
(define (E t) (F (cons (list 'F (FQ 'C t)) t)))
(define (F t) (CGOTO t 2))
(define (G t) (H (cons (list 'H (FQ 'C t)) t)))
(define (H t) (CGOTO t 3))
(define (I t) (J (cons (list 'J (FQ 'G t)) t)))
(define (J t) (CGOTO t 1))
(define (K t) (L (cons (list 'L (FQ 'E t)) t)))
(define (L t) (CGOTO t 1))
(define (M t) (N (cons (list 'N (FQ 'C t)) t)))
(define (N t) (CGOTO t 4))
(define (O t) (P (cons (list 'P 1) t)))
(define (Q t) (R (cons (list 'R (FQ 'O t)) t)))
(define (R t) (CGOTO t 1))
(define (S t) (T (cons (list 'T (FQ 'Q t)) t)))
(define (T t) (CGOTO t 1))
(define (U t) (V (cons (list 'V (FQ 'O t)) t)))
(define (V t) (CGOTO t 2))
(define (W t) (X (cons (list 'X 1) t)))
(define (Y t) (Z (cons (list 'Z (FQ 'W t)) t)))
(define (Z t) (CGOTO t 1))
(define (AA t) (AB (cons (list 'AB (FQ 'Y t)) t)))
(define (AB t) (CGOTO t 1))
(define (AA1 t) (AB1 (cons (list 'AB1 (FQ 'W t)) t)))
(define (AB1 t) (CGOTO t 2))
(define (AC t) (AD (cons (list 'AD 1) t)))
(define (AD t) (AE (cons (list 'AE (length t)) t)))
(define (AE t) (AF (cons (list 'AF (FQ 'AC t)) t)))
(define (AF t) (CGOTO t 1))
(define (AG t) (AH (cons (list 'AH 1) t)))
(define (AH t) (cons 'END-OF-TRAVERSAL t))

(define (X t) (AA1 (cons (list 'AA1 (length t)) t)))
(define (X t) (Y (cons (list 'Y (length t)) t)))
(define (P t) (U (cons (list 'U (length t)) t)))
(define (P t) (Q (cons (list 'Q (length t)) t)))

(reverse (A '((A 0))))