#lang racket
(define (CGOTO t i) (let ((q (- (cadar t) 1))) (CGOTO1 (caar (pfx q t)) t q i)))
(define (CGOTO1 have t p i)
  (if (not (member have '(F J B)))
      (if (equal? have 'App)
          (if (equal? i 1) (K (cons (list 'K p) t)) (error 'GOTO:ERROR))
          (if (equal? have 'B)
              (if (equal? i 1) (C (cons (list 'C p) t)) (error 'GOTO:ERROR))
              (if (equal? have 'D)
                  (if (equal? i 2)
                      (I (cons (list 'I p) t))
                      (if (equal? i 1) (E (cons (list 'E p) t)) (error 'GOTO:ERROR)))
                  (if (equal? have 'F)
                      (if (equal? i 1) (G (cons (list 'G p) t)) (error 'GOTO:ERROR))
                      (if (equal? have 'L)
                          (if (equal? i 1) (M (cons (list 'M p) t)) (error 'GOTO:ERROR))
                          (if (equal? have 'N)
                              (if (equal? i 1) (O (cons (list 'O p) t)) (error 'GOTO:ERROR))
                              (error 'ERROR)))))))
      (cons `EOT t)))
(define (FQ have t)
  (letrec ((f
            (lambda (t0)
              (if (equal? have (caar t0))
                  (length t0)
                  (let ((bp (cadar t0))) (f (pfx (- bp 1) t)))))))
    (f t)))
(define (pfx n t) (reverse (take n (reverse t))))
(define (take n xs) (if (equal? n 0) '() (cons (car xs) (take (- n 1) (cdr xs)))))
(define (travout t) (if (null? t) '() (begin (travout (cdr t)) (newline) (write (car t)))))
(define (Root t) (App (cons (list 'App 0) t)))
(define (App t) (A (cons (list 'A (length t)) t)))
(define (A t) (B (cons (list 'B 1) t)))
(define (B t) (C (cons (list 'C (length t)) t)))
(define (C t) (D (cons (list 'D (FQ 'A t)) t)))
(define (D t) (CGOTO t 1))
(define (E t) (F (cons (list 'F 1) t)))
(define (F t) (G (cons (list 'G (length t)) t)))
(define (G t) (H (cons (list 'H (FQ 'E t)) t)))
(define (H t) (CGOTO t 1))
(define (I t) (J (cons (list 'J 1) t)))
(define (J t) (cons 'END-OF-TRAVERSAL t))
(define (K t) (L (cons (list 'L (FQ 'K t)) t)))
(define (L t) (CGOTO t 1))
(define (M t) (N (cons (list 'N (FQ 'K t)) t)))
(define (N t) (CGOTO t 1))
(define (O t) (P (cons (list 'P (FQ 'K t)) t)))
(define (P t) (CGOTO t 2))
(reverse (Root '((Root 0))))