\documentclass[a4paper, 12pt]{article} %размер бумаги устанавливаем А4, шрифт 15пунктов
\usepackage[margin=0.5in]{geometry}
% \usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[utf8]{inputenc}%кодировка
\usepackage[russian]{babel}%используем русский и английский языки с переносами
% \graphicspath{{/}}%путь к рисункам
\usepackage{cite}
\usepackage{multirow}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{ amssymb }
\usepackage{ amsmath}
\usepackage{listings}
\usepackage{xcolor}
\graphicspath{{pictures/}}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dred}{rgb}{0.545,0,0}
\definecolor{dblue}{rgb}{0,0,0.545}
\definecolor{lgrey}{rgb}{0.9,0.9,0.9}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}

\usepackage{minted}

\usepackage[labelformat=empty]{caption}
\usepackage{fontspec}
\usepackage{polyglossia}
\setdefaultlanguage{russian}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont{CMU Serif}
\setsansfont{CMU Sans Serif}
\setmonofont{CMU Typewriter Text}


\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}

\begin{document}
\section{Algorithm constrcuting traversal for untyped lambda calculus}
\textbf{Comments:}
\begin{enumerate}
\item pointers (each traversal element have three pointers):
  \begin{enumerate}
  \item bp2\_ --- global pointer to the last unfinished application (LUA)
  \item bp3\_ --- local pointer to the last unapplied application
  \item bp4\_
    \begin{itemize}
    \item BVar case --- binder pointer
    \item FVar case --- 0
    \item otherwise --- pointer to the parent (in terms of tree structure)
    \end{itemize}
  \end{enumerate}
\item also each traversal element have a boolean flag; (if it is set that means that in this point we got stack and started to look for the latest unfinished application)
\item last unfinished application --- LUA
\item there is no difference between a free variable case and a bound variable case whose binder(lambda) is not "applied"
\end{enumerate}


\textbf{Pseudo-code:}
\begin{minted}{haskell}
input: tr@((x, b_x, bp2_x bp3_x, bp4_x):t)
case x of
  
  (App): e _
    let bp4_e = computeBI e |tr|
    in (e, False, |tr|, |tr|, bp4_e):tr

  (Abs): \ _ . e
    let bp4_e = computeBI e |tr|
    in (e, False, findLastUnapplied, findLastUnapplied, bp4_e):tr
    | findLastUnapplied:
    |   (Abs) -> let tr'@((_ , _, bp2_', _, _):_) = get element bp2_ from tr
    |            in rec call bp2_'
    |   (App) -> return
    |   (Var) -> goto element bp2_     and rec call

  (BVar): z
    if exists bound argument (e, i)
    | Invariants:
    |   e --- term to be substituted instead of variable z
    |   i --- an application location in traversal (e is a child of this application)
    | Finding bound argument:
    |   1) make a step through bp4_x (Invariant: we reach a binder)
    |   2) if bp3_binder == 0
    |      then Nothing
    |      else make a step through bp3_binder (Invariant: we reach an (App): _ e2)
    |           return Just (e2, bp3_binder)
    then (e, False, bp2_x, bp3_x, computeBI tr e i)
    else GOTO_(FVar)

  (FVar): z
    if exists (the latest one) unfinished application (e, i)
    | Invariants:
    |   e --- argument of the LUA
    |   i --- pointer to the "new" LUA
    | Finding unfinished application:
    |   if bp2_x == 0
    |   then Nothing
    |   else make a step through bp2_x (Invariant: we reach an (App): _ e2)
    |        return Just (e2, bp2_app)
    then if e == (Abs)
    | then (e, False, i+1, 0, computeBI tr e bp2_x):(x, True, bp2_x bp3_x, bp4_x):t
    | else (e, False, i  , 0, computeBI tr e bp2_x):(x, True, bp2_x bp3_x, bp4_x):t
    else END_OF_TRAVERSAL

where
computeBI e i =case e of
    BVar -> Find Dynamic Binder (starting from a position i in tr go through bp4_
                                 until binder will not be reached)
    FVar -> 0
    _    -> |tr|
\end{minted}

\subsection*{Find Last Unapplied}
\begin{minted}{haskell}

(Abs): rec go to bp2_ - 1
(App): its oun position
(Var): rec go to bp_2

\end{minted}



\section{TODO}
\begin{enumerate}
\item proof correctness
\end{enumerate}

\end{document}








